<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SatcomCoordinates.jl</title>
    <meta name="description" content="Documentation for SatcomCoordinates.jl">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/SatcomCoordinates.jl/dev/assets/style.B1KcXeqy.css" as="style">
    <link rel="preload stylesheet" href="/SatcomCoordinates.jl/dev/vp-icons.css" as="style">
    
    <script type="module" src="/SatcomCoordinates.jl/dev/assets/app._mZ0ocvv.js"></script>
    <link rel="preload" href="/SatcomCoordinates.jl/dev/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/SatcomCoordinates.jl/dev/assets/chunks/theme.CyDdBSwX.js">
    <link rel="modulepreload" href="/SatcomCoordinates.jl/dev/assets/chunks/framework.ZUoQK9cX.js">
    <link rel="modulepreload" href="/SatcomCoordinates.jl/dev/assets/index.md.Pr4UPEjG.lean.js">
    <script src="/SatcomCoordinates.jl/versions.js"></script>
    <script src="/SatcomCoordinates.jl/dev/siteinfo.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-492508fc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-492508fc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-0f4f798b><a class="title" href="/SatcomCoordinates.jl/dev/" data-v-0f4f798b><!--[--><!--]--><!----><span data-v-0f4f798b>SatcomCoordinates.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/SatcomCoordinates.jl/dev/index" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/SatcomCoordinates.jl/dev/performance" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Performance Examples</span><!--]--></a><!--]--><!--[--><!----><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-04f5c5e9><span class="vpi-more-horizontal icon" data-v-04f5c5e9></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-168ddf5d><button data-v-168ddf5d>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0" data-v-9e426adc data-v-a4b0d9bf><!----><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SatcomCoordinates.jl/dev/index" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Home</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SatcomCoordinates.jl/dev/performance" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Performance Examples</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _SatcomCoordinates_jl_dev_" data-v-83890dd9><div><h1 id="satcomcoordinates-jl" tabindex="-1">SatcomCoordinates.jl <a class="header-anchor" href="#satcomcoordinates-jl" aria-label="Permalink to &quot;SatcomCoordinates.jl&quot;">​</a></h1><p>Documentation for <code>SatcomCoordinates.jl</code>.</p><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ForwardOrInverse" href="#SatcomCoordinates.ForwardOrInverse"><span class="jlbinding">SatcomCoordinates.ForwardOrInverse</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardOrInverse{F </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSTransform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{F, InverseTransform{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span></span></code></pre></div><p>Union representing either a forward or reverse transform of F</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/type_aliases.jl#L41-L45" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.GenericLocalPosition" href="#SatcomCoordinates.GenericLocalPosition"><span class="jlbinding">SatcomCoordinates.GenericLocalPosition</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenericLocalPosition{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{LocalCartesian{T}, GeneralizedSpherical{T}}</span></span></code></pre></div><p>Union of all types that can represent a position in a generic local coordinate system.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/type_aliases.jl#L33-L37" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.GeocentricPosition" href="#SatcomCoordinates.GeocentricPosition"><span class="jlbinding">SatcomCoordinates.GeocentricPosition</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GeocentricPosition{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{ECEF{T}, ECI{T}, LLA{T}}</span></span></code></pre></div><p>Union of all types that can represent a position in the geocentric coordinate system.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/type_aliases.jl#L2-L6" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.TopocentricPosition" href="#SatcomCoordinates.TopocentricPosition"><span class="jlbinding">SatcomCoordinates.TopocentricPosition</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TopocentricPosition{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{ENU{T}, NED{T}, AER{T}}</span></span></code></pre></div><p>Union of all types that can represent a position in a topocentric coordinate system.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/type_aliases.jl#L10-L14" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.WithNumbertype" href="#SatcomCoordinates.WithNumbertype"><span class="jlbinding">SatcomCoordinates.WithNumbertype</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WithNumbertype{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{AbstractSatcomCoordinate{T}, AbstractCRSTransform{T}}</span></span></code></pre></div><p>Union representing the types defined and exported by this package, which always have a numbertype as first parameter.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/type_aliases.jl#L48-L52" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AER" href="#SatcomCoordinates.AER"><span class="jlbinding">SatcomCoordinates.AER</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AER{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngleAngleDistance{T}</span></span></code></pre></div><p>Represents a position in the Azimuth-Elevation-Range (AER) coordinate system, which is a local coordinate system centered at a point on or above the surface of an Ellipsoid. The Elevation and Azimuth angles are always defined w.r.t. the ENU CRS with the same origin. More specifically:</p><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}</code>: Azimuth angle, defined angle in the XY (North-East) plane from the +Y (North) direction to the object, positive towards +X (East) direction. It is constrained to be in the range <code>[-180°, 180°]</code></p></li><li><p><code>el::Deg{T}</code>: Elevation angle, defined as the angle between the XY plane and the point being described by the AER coordinates, positive towards +Z (Up) direction. It is constrained to be in the range <code>[-90°, 90°]</code></p></li><li><p><code>r::Met{T}</code>: Range in meters between the origin of the ENU CRS and the point being described by the AER coordinates.</p></li></ul><p>The fields of <code>AER</code> objects can also be accessed via <code>getproperty</code> using the follwing alternative aliases:</p><ul><li><p><code>azimuth</code> for <code>az</code></p></li><li><p><code>elevation</code> for <code>el</code></p></li><li><p><code>range</code> or <code>distance</code> for <code>r</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>AER(az::ValidAngle, el::ValidAngle, r::ValidDistance)</span></span></code></pre></div><p><code>ValidAngle</code> is either a Real Number, or a subtype of <code>Unitful.Angle</code>. <code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>AER</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.ENU"><code>ENU</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.NED"><code>NED</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/topocentric.jl#L72-L99" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AbstractPointing" href="#SatcomCoordinates.AbstractPointing"><span class="jlbinding">SatcomCoordinates.AbstractPointing</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractPointing{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, 3}</span></span></code></pre></div><p>Abstract type representing a pointing direction in 3 dimensions which is backed by fields with shared <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.numbertype"><code>numbertype</code></a> <code>T</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/abstract_types.jl#L36-L40" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AbstractPointingOffset" href="#SatcomCoordinates.AbstractPointingOffset"><span class="jlbinding">SatcomCoordinates.AbstractPointingOffset</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractPointingOffset{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, 2}</span></span></code></pre></div><p>Abstract type representing a pointing offset between two pointing directions.</p><p>Currently only has two concrete subtypes: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.UVOffset"><code>UVOffset</code></a> and <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.ThetaPhiOffset"><code>ThetaPhiOffset</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/abstract_types.jl#L51-L57" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AbstractSatcomCoordinate" href="#SatcomCoordinates.AbstractSatcomCoordinate"><span class="jlbinding">SatcomCoordinates.AbstractSatcomCoordinate</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>General abstract type identifying a <em>coordinate</em> with <code>N</code> dimensions and an underlying number type <code>T</code>. The number type <code>T</code> is not necessarily the type of the fields in the type instance, but their underlying real type (this is only different for fields whose types are Unitful quantities, where <code>numbertype(::Quantity{T}) where T = T</code>).</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The term <em>coordinate</em> is used here in a loose sense, identifying both position in space as well as pointing directions</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/abstract_types.jl#L1-L8" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AngleAngleDistance" href="#SatcomCoordinates.AngleAngleDistance"><span class="jlbinding">SatcomCoordinates.AngleAngleDistance</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AngleAngleDistance{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, 3}</span></span></code></pre></div><p>Abstract type representing a position in 3 dimensions, identified by two angles and a distance.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/abstract_types.jl#L13-L17" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AngularPointing" href="#SatcomCoordinates.AngularPointing"><span class="jlbinding">SatcomCoordinates.AngularPointing</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AngularPointing{T}</span></span></code></pre></div><p>Abstract type representing a pointing direction identified by two angles in degrees, represented with fields of types <code>Deg{T}</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/abstract_types.jl#L43-L48" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AzEl" href="#SatcomCoordinates.AzEl"><span class="jlbinding">SatcomCoordinates.AzEl</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AzEl{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Elevation/Azimuth&quot; coordinates, defined following the convention used for Azimuth-Elevation-Range (<a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AER"><code>AER</code></a>) coordinates used by MATLAB and by this package.</p><p>This represents the azimuth/elevation definition often used for describing pointing from a user terminal on ground towards a satellite. They are very similar to the <code>ElOverAz</code> definition but with a rotation of the underlying CRS such that elevation is 90° in the direction of the +Z axis and azimuth is computed on the XY plane from the +Y axis towards the +X axis.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>El</code> and <code>Az</code> angles is:</p><ul><li><p><code>u = cos(El) * sin(Az)</code></p></li><li><p><code>v = cos(El) * cos(Az)</code></p></li><li><p><code>w = sin(El)</code></p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The fields of <code>AzEl</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p></div><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ElOverAz"><code>ElOverAz</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#AzOverEl"><code>AzOverEl</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/pointing.jl#L167-L187" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AzElDistance" href="#SatcomCoordinates.AzElDistance"><span class="jlbinding">SatcomCoordinates.AzElDistance</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AzElDistance{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GeneralizedSpherical{T, AzEl{T}}</span></span></code></pre></div><p>Type representing a position w.r.t. a local CRS in Azimuth, Elevation and Range coordinates. The difference between <code>AzElDistance</code> and <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AER"><code>AER</code></a> is that <code>AER</code> is a always referred to the ENU CRS, while <code>AzElDistance</code> is for a generic local CRS.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/type_aliases.jl#L25-L30" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AzOverEl" href="#SatcomCoordinates.AzOverEl"><span class="jlbinding">SatcomCoordinates.AzOverEl</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AzOverEl{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Azimuth over Elevation&quot; coordinates, which specify the elevation and azimuth angles that needs to be fed to an azimuth-over-elevation positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>Az</code> and <code>El</code> angles is:</p><ul><li><p><code>u = -sin(Az)</code></p></li><li><p><code>v = cos(Az) * sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The equations above are used to represent the &quot;Azimuth over Elevation&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with a possible flip in the az/u sign) are used to describe an &quot;Elevation over Azimuth&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p></div><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The fields of <code>AzOverEl</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/pointing.jl#L106-L127" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.BasicCRSTransform" href="#SatcomCoordinates.BasicCRSTransform"><span class="jlbinding">SatcomCoordinates.BasicCRSTransform</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BasicCRSTransform{T, R </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Union{CRSRotation{T}, Identity}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, O </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianPosition{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSTransform{T}</span></span></code></pre></div><p>A type representing a basic transformation (rotation + translation).</p><p><strong>Fields:</strong></p><ul><li><p><code>rotation::R</code>: The rotation of the transformation.</p></li><li><p><code>origin::O</code>: The origin of the transformation.</p></li></ul><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/transforms.jl#L21-L29" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.CRSRotation" href="#SatcomCoordinates.CRSRotation"><span class="jlbinding">SatcomCoordinates.CRSRotation</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CRSRotation{T, R </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> StaticMatrix{T, 3, 3}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSRotation{T}</span></span></code></pre></div><p>A type representing a basic rotation of a coordinate system.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/transforms.jl#L12-L16" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.CartesianPosition" href="#SatcomCoordinates.CartesianPosition"><span class="jlbinding">SatcomCoordinates.CartesianPosition</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CartesianPosition{T, N} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>Abstract type representing a coordinate in <code>N</code> dimensions which is backed by fields all of type <code>T</code>. Concrete subtypes of this are subtypes of <code>FieldVector</code></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/abstract_types.jl#L20-L26" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ECEF" href="#SatcomCoordinates.ECEF"><span class="jlbinding">SatcomCoordinates.ECEF</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ECEF{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the Earth-Centered, Earth-Fixed (ECEF) coordinate system (or generically for other planets, Ellipsoid-Centered, Ellipsoid-Fixed).</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ECEF(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>ECEF</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECI"><code>ECI</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#LLA"><code>LLA</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/geocentric.jl#L1-L22" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ECI" href="#SatcomCoordinates.ECI"><span class="jlbinding">SatcomCoordinates.ECI</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ECI{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the Earth-Centered, Inertial (ECI) coordinate system (or generically for other planets, Ellipsoid-Centered, Inertial).</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ECI(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>ECI</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECEF"><code>ECEF</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#LLA"><code>LLA</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/geocentric.jl#L31-L52" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ENU" href="#SatcomCoordinates.ENU"><span class="jlbinding">SatcomCoordinates.ENU</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ENU{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the East-North-Up (ENU) coordinate system, which is a local coordinate system centered at a point on or above the surface of an Ellipsoid. The direction of the ENU axes is uniquely determined by the latitude, longitude, and altitude of the point w.r.t. the referenced ellipsoid.</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p>The fields of <code>ENU</code> objects can also be accessed via <code>getproperty</code> using the follwing alternative aliases:</p><ul><li><p><code>east</code> for <code>x</code></p></li><li><p><code>north</code> for <code>y</code></p></li><li><p><code>up</code> for <code>z</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ENU(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>ENU</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.NED"><code>NED</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AER"><code>AER</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/topocentric.jl#L1-L28" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ElOverAz" href="#SatcomCoordinates.ElOverAz"><span class="jlbinding">SatcomCoordinates.ElOverAz</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ElOverAz{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Elevation over Azimuth&quot; coordinates, which specify the azimuth and elevation angles that needs to be fed to an elevation-over-azimuth positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>El</code> and <code>Az</code> angles is:</p><ul><li><p><code>u = -sin(Az) * cos(El)</code></p></li><li><p><code>v = sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The equations above are used to represent the &quot;Elevation over Azimuth&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with sometimes an additional flip in the az/u sign) are used to describe an &quot;Azimuth over Elevation&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p></div><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The fields of <code>ElOverAz</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p></div><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/pointing.jl#L136-L159" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.GeneralizedSpherical" href="#SatcomCoordinates.GeneralizedSpherical"><span class="jlbinding">SatcomCoordinates.GeneralizedSpherical</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GeneralizedSpherical{T, P </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngleAngleDistance{T}</span></span></code></pre></div><p>Represents a position in a local CRS, defined by an angular pointing direction and a distance.</p><p><strong>Fields</strong></p><ul><li><p><code>pointing::P</code>: The pointing direction of the object</p></li><li><p><code>r::Met{T}</code>: The distance of the object from the origin of the CRS</p></li></ul><p>The <code>r</code> field can also be accessed via <code>getproperty</code> using the <code>distance</code> alias:</p><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PointingAndDistance(pointing::P, r::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>PointingAndDistance</code> object will contain <code>NaN</code> for all fields.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.Spherical"><code>Spherical</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AzElDistance"><code>AzElDistance</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.LocalCartesian"><code>LocalCartesian</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/local.jl#L32-L50" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.InverseTransform" href="#SatcomCoordinates.InverseTransform"><span class="jlbinding">SatcomCoordinates.InverseTransform</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InverseTransform{T, F </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSTransform{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSTransform{T}</span></span></code></pre></div><p>A type representing an inverse of an <a href="./@ref"><code>AbstractCRSTransform</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/transforms.jl#L1-L5" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.LLA" href="#SatcomCoordinates.LLA"><span class="jlbinding">SatcomCoordinates.LLA</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LLA{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngleAngleDistance{T}</span></span></code></pre></div><p>Identify a point on or above earth using geodetic coordinates</p><p><strong>Fields</strong></p><ul><li><p><code>lat::Deg{T}</code>: Latitude of the point in degrees [-90°, 90°]</p></li><li><p><code>lon::Deg{T}</code>: Longitude of the point in degrees [-180°, 180°]</p></li><li><p><code>alt::Met{T}</code>: Altitude of the point above the reference ellipsoid</p></li></ul><p>The fields of <code>LLA</code> objects can also be accessed via <code>getproperty</code> using the follwing alternative aliases:</p><ul><li><p><code>latitude</code> for <code>lat</code></p></li><li><p><code>longitude</code> for <code>lon</code></p></li><li><p><code>altitude</code>, <code>h</code> or <code>height</code> for <code>alt</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LLA(lat::ValidAngle,lon::ValidAngle,alt::ValidDistance)</span></span>
<span class="line"><span>LLA(lat::ValidAngle,lon::ValidAngle) # Defaults to 0m altitude</span></span></code></pre></div><p><code>ValidAngle</code> is a either a Real number or a <code>Unitful.Quantity</code> of unit either <code>u&quot;rad&quot;</code> or <code>u&quot;°&quot;</code>.</p><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>LLA</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECEF"><code>ECEF</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ECI"><code>ECI</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/geocentric.jl#L61-L91" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.LengthCartesian" href="#SatcomCoordinates.LengthCartesian"><span class="jlbinding">SatcomCoordinates.LengthCartesian</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LengthCartesian{T, N} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianPosition{T, N}</span></span></code></pre></div><p>Abstract type representing a coordinate in <code>N</code> dimensions which is backed by fields all of type <code>Met{T}</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/abstract_types.jl#L29-L33" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.LocalCartesian" href="#SatcomCoordinates.LocalCartesian"><span class="jlbinding">SatcomCoordinates.LocalCartesian</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LocalCartesian{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in a generic local CRS.</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalCartesian(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>LocalCartesian</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.GeneralizedSpherical"><code>GeneralizedSpherical</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/local.jl#L1-L22" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.NED" href="#SatcomCoordinates.NED"><span class="jlbinding">SatcomCoordinates.NED</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NED{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the North-East-Down (NED) coordinate system, which is a local coordinate system centered at a point on or above the surface of an Ellipsoid. The direction of the NED axes is uniquely determined by the latitude, longitude, and altitude of the point w.r.t. the referenced ellipsoid.</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p>The fields of <code>NED</code> objects can also be accessed via <code>getproperty</code> using the follwing alternative aliases:</p><ul><li><p><code>north</code> for <code>x</code></p></li><li><p><code>east</code> for <code>y</code></p></li><li><p><code>down</code> for <code>z</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>NED(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>NED</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.ENU"><code>ENU</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AER"><code>AER</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/topocentric.jl#L37-L64" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.PointingVersor" href="#SatcomCoordinates.PointingVersor"><span class="jlbinding">SatcomCoordinates.PointingVersor</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PointingVersor{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T}</span></span></code></pre></div><p>A unit vector (versor) representing a pointing direction in 3D space. Its components are the <code>x</code>, <code>y</code>, and <code>z</code> components of the unit vector and can also be seen as the <code>u</code>, <code>v</code>, and <code>w</code> direction cosines of the direction identified by the <code>PointingVersor</code> instance.</p><p><strong>Fields</strong></p><ul><li><p><code>x::T</code>: The component along the X axis of the corresponding reference frame. Can also be accessed with the <code>u</code> property name.</p></li><li><p><code>y::T</code>: The component along the Y axis of the corresponding reference frame. Can also be accessed with the <code>v</code> property name.</p></li><li><p><code>z::T</code>: The component along the Z axis of the corresponding reference frame. Can also be accessed with the <code>w</code> property name.</p></li></ul><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ElOverAz"><code>ElOverAz</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/pointing.jl#L1-L15" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.Spherical" href="#SatcomCoordinates.Spherical"><span class="jlbinding">SatcomCoordinates.Spherical</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spherical{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GeneralizedSpherical{T, ThetaPhi{T}}</span></span></code></pre></div><p>Type representing a position in ISO/Physics spherical coordinates</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/type_aliases.jl#L18-L22" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ThetaPhi" href="#SatcomCoordinates.ThetaPhi"><span class="jlbinding">SatcomCoordinates.ThetaPhi</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThetaPhi{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>An object specifying a pointing direction in ThetaPhi coordinates, defined as the θ and φ in the (ISO/Physics definition) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a></p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>θ</code> and <code>φ</code> angles is:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li><li><p><code>w = cos(θ)</code></p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>θ::Deg{T}</code>: The so-called <code>polar angle</code>, representing the angle between the <code>Z</code> axis and the <code>XY</code> plane of the reference frame. It is always normalized to fall within the [-90°, 90°] range.</p></li><li><p><code>φ::Deg{T}</code>: The so-called <code>azimuth angle</code>, representing the angle between the <code>y</code> and <code>x</code> component of the pointing direction. It is always normalized to fall within the [-180°, 180°] range.</p></li></ul><p>While the field name use the greek letters, the specific fields of an arbitrary <code>ThetaPhi</code> object <code>tp</code> can be accessed with alternative symbols:</p><ul><li><p><code>tp.θ</code>, <code>tp.theta</code> and <code>tp.t</code> can be used to access the <code>θ</code> field</p></li><li><p><code>tp.φ</code>, <code>tp.ϕ</code>, <code>tp.phi</code> and <code>tp.p</code> can be used to access the <code>φ</code> field</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(θ,φ)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>θ</code>, <code>φ</code> and instantiate the object. MarkdownAST.LineBreak()</p><p><strong>Provided inputs are intepreted as degrees if not provided using angular quantities from Unitful.</strong> If either of the inputs is <code>NaN</code>, the returned <code>ThetaPhi</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(tp)</span></span></code></pre></div><p>The <code>ThetaPhi</code> struct can be created using any 2-element Tuple or Vector/StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/pointing.jl#L64-L98" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ThetaPhiOffset" href="#SatcomCoordinates.ThetaPhiOffset"><span class="jlbinding">SatcomCoordinates.ThetaPhiOffset</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThetaPhiOffset{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointingOffset{T}</span></span></code></pre></div><p>Type used to describe an angular offset between two pointing directions.</p><p>The ThetaPhiOffset coordinates must satisfy:</p><ul><li><p><code>theta ∈ [-90, 90]</code></p></li><li><p><code>phi ∈ [-180, 180]</code></p></li></ul><p>This type is mostly used with the <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a> and <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a> functions.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/pointing_offsets.jl#L24-L34" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.UV" href="#SatcomCoordinates.UV"><span class="jlbinding">SatcomCoordinates.UV</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UV{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T}</span></span></code></pre></div><p>Specify a pointing direction in UV coordinates, which are equivalent to the direction cosines with respect to the <code>X</code> and <code>Y</code> axis of the reference frame. They can also be related to the spherical coordinates (ISO/Physics) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a> by the following equations:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>UV coordinates can only be used to represent pointing direction in the half-hemisphere containing the cartesian +Z axis.</p></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The inputs values must also satisfy <code>u^2 + v^2 &lt;= 1 + SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE[]</code> or an error will be thrown. The <code>SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE</code> is a <code>Ref{Float64}</code> which defaults to 1e-5 (In case <code>u^2 + v^2 &gt; 1</code> the inputs are normalized to ensure <code>u^2 + v^2 = 1</code>).</p></div><p><strong>Fields</strong></p><ul><li><p><code>u::T</code></p></li><li><p><code>v::T</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(u,v)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>u</code>, <code>v</code> and instantiate the object assuming that <code>u^2 + v^2 &lt;= 1</code> (condition for valid UV pointing), throwing an error otherwise. MarkdownAST.LineBreak()</p><p>If either of the inputs is <code>NaN</code>, the returned <code>UV</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(uv)</span></span></code></pre></div><p>The <code>UV{T}</code> can be created using any 2-element Tuple or StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/pointing.jl#L25-L56" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.UVOffset" href="#SatcomCoordinates.UVOffset"><span class="jlbinding">SatcomCoordinates.UVOffset</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UVOffset{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointingOffset{T}</span></span></code></pre></div><p>Type used to describe an offset in UV coordinates.</p><p>The UVOffset coordinates must satisfy:</p><ul><li><code>sqrt(u^2 + v^2) ≤ 2</code></li></ul><p>This type is mostly generated indirectly when subtracting two pointing directions expressed in UV.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/types/pointing_offsets.jl#L1-L10" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}" href="#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><span class="jlbinding">SatcomCoordinates.add_angular_offset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₀</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, offset_angles</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{ThetaPhi, ThetaPhiOffset}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₀</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointingType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output_type, p₀, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the resulting pointing direction <code>p</code> obtained by adding an angular offset expressed as θ and φ angles (following the ISO/Physics convention for spherical coordinates) [deg] to the starting position identified by <code>p₀</code>.</p><p>The input starting position <code>p₀</code> must be any subtype of <code>AbstractPointing</code> The input <code>offset_angles</code> can be provided as an instance of one of the following types:</p><ul><li><p><code>ThetaPhi</code></p></li><li><p><code>ThetaPhiOffset</code></p></li></ul><p>and is converted to <code>ThetaPhiOffset</code> internally, with non-unitful values being interpreted as angles in degrees.</p><p>The output is of type <code>output_type</code> if provided or of the same type as <code>p₀</code> otherwise.</p><p><strong>Note</strong></p><p>If <code>output_type</code> is <code>UV</code>, the function will throw an error if the final pointing direction is located behind the viewer as the output in UV would be ambiguous. This is not the case for other subtypes of <code>AbstractPointing</code> so an explicit output type (different from <code>UV</code>) should be provided if the target is expected to be behind the viewer.</p><p>The offset angles can also be provided separately as 2nd and 3rd argument (optional, defaults to 0.0) to the function using the second method signature. In this case, the inputs are treated as angles in degrees unless explicitly provided using quantitites with <code>°</code> unit from the Unitful package.</p><p>This function performs the inverse operation of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a> so the following code should return true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SatcomCoordinates</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, offset)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv2</span></span></code></pre></div><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_distance</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/functions/pointing_offsets.jl#L164-L202" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.angle_offset_rotation-Tuple{Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T}" href="#SatcomCoordinates.angle_offset_rotation-Tuple{Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T}"><span class="jlbinding">SatcomCoordinates.angle_offset_rotation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">angle_offset_rotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ, φ)</span></span></code></pre></div><p>Compute the rotation matrix to find offset points following the procedure in this stackexchnge answer: <a href="https://math.stackexchange.com/questions/4343044/rotate-vector-by-a-random-little-amount" target="_blank" rel="noreferrer">https://math.stackexchange.com/questions/4343044/rotate-vector-by-a-random-little-amount</a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/functions/pointing_offsets.jl#L75-L81" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.change_numbertype" href="#SatcomCoordinates.change_numbertype"><span class="jlbinding">SatcomCoordinates.change_numbertype</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">change_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x)</span></span></code></pre></div><p>Functions that change the underlying numbertype of the provided object <code>x</code> to the first argument <code>T</code>.</p><p>It has a fallback default implementation for types defined within this package which calls <code>convert</code> on the provided object <code>x</code> to the type <code>basetype(x){T}</code>.</p><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.numbertype"><code>numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.enforce_numbertype"><code>enforce_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.has_numbertype"><code>has_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N"><code>default_numbertype</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L45-L53" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N" href="#SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N"><span class="jlbinding">SatcomCoordinates.default_numbertype</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">default_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Function that returns the common valid numbertype among the arguments provided as input. It finds the common numbertype via <code>promote_type</code> and either return that (if it&#39;s a subtype of <code>AbstractFloat</code>) or <code>Float64</code> if it&#39;s not.</p><p>This function is useful to automatically extract from inputs the <code>numbertype</code> to use in constructors.</p><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.numbertype"><code>numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.enforce_numbertype"><code>enforce_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.has_numbertype"><code>has_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.change_numbertype"><code>change_numbertype</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L56-L64" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.enforce_numbertype" href="#SatcomCoordinates.enforce_numbertype"><span class="jlbinding">SatcomCoordinates.enforce_numbertype</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input_type, [default_numbertype]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {C </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Union{AbstractSatcomCoordinate, AbstractCRSTransform}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Function that takes as input a type and returns a potentialy more specialized subtype of the input type with the numbertype parameter set if not specified in <code>input_type</code>. Optionally, this function accepts a secon type (or value) as argument and infers the numbertype to set as default (if not alredy present). The default numbertype when the function is called with 1-argument is <code>Float64</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV{Float64} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Provide a default as not present in input type</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV{Float32}) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV{Float32} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Returns the same input type as it already has a numbertype</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV, Float32) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV{Float32} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Provide a custom default as not present in input type</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV{Int64} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Provide a custom default as not present in input type</span></span></code></pre></div><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.numbertype"><code>numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.enforce_numbertype"><code>enforce_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.has_numbertype"><code>has_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N"><code>default_numbertype</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L27-L42" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}" href="#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"><span class="jlbinding">SatcomCoordinates.get_angular_distance</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_angular_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₁</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p₂</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the angular distance [°] between the target pointing direction <code>p₂</code> and the starting pointing direction <code>p₁</code>.</p><p><strong>Note</strong></p><p>This function&#39;s output should be approximately equivalent to the θ (theta) component of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a> but has a faster implementation. Use this in case the φ (phi) component is not required and speed is important. The following code should evaluate to true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SatcomCoordinates</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Δθ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">theta </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Δθ</span></span></code></pre></div><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/functions/pointing_offsets.jl#L47-L68" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}" href="#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><span class="jlbinding">SatcomCoordinates.get_angular_offset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₁</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p₂</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThetaPhiOffset</span></span></code></pre></div><p>Compute the angular offset required to reach the target pointing direction <code>p₂</code> from starting pointing direction <code>p₁</code>. The two input pointings can be of any valid <code>AbstractPointing</code> type.</p><p>The output is of type <code>ThetaPhiOffset</code></p><p><strong>Note</strong></p><p>This function performs the inverse operation of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a> so the following code should return true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReferenceViews</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, offset)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv2</span></span></code></pre></div><p>Check out <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_distance</code></a> for a slightly faster implementation in case you only require the angular distance rather than the 2D offset.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/functions/pointing_offsets.jl#L124-L149" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.has_numbertype" href="#SatcomCoordinates.has_numbertype"><span class="jlbinding">SatcomCoordinates.has_numbertype</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">has_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">has_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This function shall return <code>true</code> if the provided type <code>T</code> or object of type <code>T</code> has an associated numbertype.</p><p>This function will return <code>false</code> for types defined within this package that do not have the numbertype parameter specified (type <code>T</code> is thus a <code>UnionAll</code> on the numbertype parameter).</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L17-L24" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.numbertype" href="#SatcomCoordinates.numbertype"><span class="jlbinding">SatcomCoordinates.numbertype</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This function shall return the underlying numbertype of the provided Type or object.</p><p>The concept of numbertype is defined here as the subtype of <code>Real</code> which is used to represent the numerical values in the object&#39;s field. It is not directly the type of the fields, mainly as we consider fields of type <code>Unitul.Quantity{T}</code> to have numbertype <code>T</code>.</p><p>All the types defined in this package have an assciated parametric numbertype as first parameter.</p><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.enforce_numbertype"><code>enforce_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.change_numbertype"><code>change_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.has_numbertype"><code>has_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N"><code>default_numbertype</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L2-L14" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.origin-Tuple{SatcomCoordinates.AbstractAffineCRSTransform}" href="#SatcomCoordinates.origin-Tuple{SatcomCoordinates.AbstractAffineCRSTransform}"><span class="jlbinding">SatcomCoordinates.origin</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">origin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractAffineCRSTransform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This function should return an object which is subtype of <code>CartesianPosition</code> and represents the origin of the starting CRS in the target CRS.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/functions/transforms.jl#L11-L15" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.raw_nt-Tuple{C} where C&lt;:AbstractSatcomCoordinate" href="#SatcomCoordinates.raw_nt-Tuple{C} where C&lt;:AbstractSatcomCoordinate"><span class="jlbinding">SatcomCoordinates.raw_nt</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">raw_nt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSatcomCoordinate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generated a NamedTuple from the provided Object which has the same names as the object fields but contains <em>normalized</em> values of its fields</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>By <em>normalized</em> we mean that fields containing Uniftul quantities are stripped of their units and in the case of <code>Deg</code> fields, they are converted to radians as trig functions are faster for radians inputs.</p></div><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.to_svector-Tuple{C} where C&lt;:AbstractSatcomCoordinate"><code>to_svector</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L124-L132" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.rotation-Tuple{CRSRotation}" href="#SatcomCoordinates.rotation-Tuple{CRSRotation}"><span class="jlbinding">SatcomCoordinates.rotation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractAffineCRSTransform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This function should return a <code>CRSRotation</code> object representing the rotation to align the starting CRS to the target CRS.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/functions/transforms.jl#L19-L23" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.to_svector-Tuple{C} where C&lt;:AbstractSatcomCoordinate" href="#SatcomCoordinates.to_svector-Tuple{C} where C&lt;:AbstractSatcomCoordinate"><span class="jlbinding">SatcomCoordinates.to_svector</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">to_svector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coord</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSatcomCoordinate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate the unitless SVector containing the <em>normalized</em> fields of the provided coordinate.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>By <em>normalized</em> we mean that fields containing Uniftul quantities are stripped of their units and in the case of <code>Deg</code> fields, they are converted to radians as trig functions are faster for radians inputs.</p></div><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.raw_nt-Tuple{C} where C&lt;:AbstractSatcomCoordinate"><code>raw_nt</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L110-L119" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T&lt;:Union{AzOverEl, ElOverAz, ThetaPhi}" href="#SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T&lt;:Union{AzOverEl, ElOverAz, ThetaPhi}"><span class="jlbinding">SatcomCoordinates.wrap_spherical_angles</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><p>!!!</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L97-L106" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{&lt;:Union{AER, AzEl, AzOverEl, ElOverAz}}}} where T&lt;:(Unitful.Quantity{&lt;:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})" href="#SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{&lt;:Union{AER, AzEl, AzOverEl, ElOverAz}}}} where T&lt;:(Unitful.Quantity{&lt;:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})"><span class="jlbinding">SatcomCoordinates.wrap_spherical_angles_normalized</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>This function already assumes that the provided input angles are already normalized such that both are in the [-180°, 180°] range. If you want to normalize the inputs automatically use the <code>wrap_first_angle</code> function.</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/a0cfb88a350235f79da2730b7311234c29469d55/src/utils.jl#L72-L82" target="_blank" rel="noreferrer">source</a></p></details></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/edit/main/docs/src/index.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><!----></div><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link next" href="/SatcomCoordinates.jl/dev/index" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Next page</span><span class="title" data-v-4f9813fa>Home</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://luxdl.github.io/DocumenterVitepress.jl/dev/" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br></p><p class="copyright" data-v-c970a860>© Copyright 2025.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"Pr4UPEjG\",\"performance.md\":\"BZHCPPpL\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"SatcomCoordinates.jl\",\"description\":\"Documentation for SatcomCoordinates.jl\",\"base\":\"/SatcomCoordinates.jl/dev/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/index\"},{\"text\":\"Performance Examples\",\"link\":\"/performance\"},{\"component\":\"VersionPicker\"}],\"sidebar\":[{\"text\":\"Home\",\"link\":\"/index\"},{\"text\":\"Performance Examples\",\"link\":\"/performance\"}],\"editLink\":{\"pattern\":\"https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/edit/main/docs/src/:path\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/dev/\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br>\",\"copyright\":\"© Copyright 2025.\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>