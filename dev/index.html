<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SatcomCoordinates.jl</title>
    <meta name="description" content="Documentation for SatcomCoordinates.jl">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/SatcomCoordinates.jl/dev/assets/style.B1KcXeqy.css" as="style">
    <link rel="preload stylesheet" href="/SatcomCoordinates.jl/dev/vp-icons.css" as="style">
    
    <script type="module" src="/SatcomCoordinates.jl/dev/assets/app.D7788r8P.js"></script>
    <link rel="preload" href="/SatcomCoordinates.jl/dev/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/SatcomCoordinates.jl/dev/assets/chunks/theme.BbsjLlEE.js">
    <link rel="modulepreload" href="/SatcomCoordinates.jl/dev/assets/chunks/framework.hSlKf8er.js">
    <link rel="modulepreload" href="/SatcomCoordinates.jl/dev/assets/index.md.DWV3ab6q.lean.js">
    <script src="/SatcomCoordinates.jl/versions.js"></script>
    <script src="/SatcomCoordinates.jl/dev/siteinfo.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-492508fc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-492508fc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-0f4f798b><a class="title" href="/SatcomCoordinates.jl/dev/" data-v-0f4f798b><!--[--><!--]--><!----><span data-v-0f4f798b>SatcomCoordinates.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/SatcomCoordinates.jl/dev/index" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/SatcomCoordinates.jl/dev/performance" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Performance Examples</span><!--]--></a><!--]--><!--[--><!----><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-04f5c5e9><span class="vpi-more-horizontal icon" data-v-04f5c5e9></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-168ddf5d><button data-v-168ddf5d>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0" data-v-9e426adc data-v-a4b0d9bf><!----><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SatcomCoordinates.jl/dev/index" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Home</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SatcomCoordinates.jl/dev/performance" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Performance Examples</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _SatcomCoordinates_jl_dev_" data-v-83890dd9><div><h1 id="satcomcoordinates-jl" tabindex="-1">SatcomCoordinates.jl <a class="header-anchor" href="#satcomcoordinates-jl" aria-label="Permalink to &quot;SatcomCoordinates.jl&quot;">​</a></h1><p>Documentation for <code>SatcomCoordinates.jl</code>.</p><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AbstractSatcomCoordinate" href="#SatcomCoordinates.AbstractSatcomCoordinate"><span class="jlbinding">SatcomCoordinates.AbstractSatcomCoordinate</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>General abstract type identifying a <em>coordinate</em> with <code>N</code> dimensions and an underlying number type <code>T</code>. The number type <code>T</code> is not necessarily the type of the fields in the type instance, but the underlying real type of the fields (this is used for Unitful quantities, such that <code>numbertype(::Quantity{T}) where T = T</code>).</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The term <em>coordinate</em> is used here in a loose sense, identifying both position in space as well as pointing directions</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/abstract_types.jl#L1-L8" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AngularPointing" href="#SatcomCoordinates.AngularPointing"><span class="jlbinding">SatcomCoordinates.AngularPointing</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AngularPointing{T}</span></span></code></pre></div><p>Abstract type representing a pointing direction identified by two angles in degrees, represented with fields of types <code>Deg{T}</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/abstract_types.jl#L23-L28" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.AzOverEl" href="#SatcomCoordinates.AzOverEl"><span class="jlbinding">SatcomCoordinates.AzOverEl</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AzOverEl{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Azimuth over Elevation&quot; coordinates, which specify the elevation and azimuth angles that needs to be fed to an azimuth-over-elevation positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>Az</code> and <code>El</code> angles is:</p><ul><li><p><code>u = sin(Az)</code></p></li><li><p><code>v = cos(Az) * sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The equations above are used to represent the &quot;Azimuth over Elevation&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with a possible flip in the az/u sign) are used to describe an &quot;Elevation over Azimuth&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The fields of <code>AzOverEl</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/pointing/types.jl#L106-L127" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.CartesianPosition" href="#SatcomCoordinates.CartesianPosition"><span class="jlbinding">SatcomCoordinates.CartesianPosition</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CartesianPosition{T, N} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>Abstract type representing a coordinate in <code>N</code> dimensions which is backed by fields all of type <code>T</code>. Concrete subtypes of this are subtypes of <code>FieldVector</code></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/abstract_types.jl#L11-L17" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ElOverAz" href="#SatcomCoordinates.ElOverAz"><span class="jlbinding">SatcomCoordinates.ElOverAz</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ElOverAz{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Elevation over Azimuth&quot; coordinates, which specify the azimuth and elevation angles that needs to be fed to an elevation-over-azimuth positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>El</code> and <code>Az</code> angles is:</p><ul><li><p><code>u = -sin(Az) * cos(El)</code></p></li><li><p><code>v = sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The equations above are used to represent the &quot;Elevation over Azimuth&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with sometimes an additional flip in the az/u sign) are used to describe an &quot;Azimuth over Elevation&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The fields of <code>ElOverAz</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/pointing/types.jl#L136-L159" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.PointingVersor" href="#SatcomCoordinates.PointingVersor"><span class="jlbinding">SatcomCoordinates.PointingVersor</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PointingVersor{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T, 3}</span></span></code></pre></div><p>A unit vector (versor) representing a pointing direction in 3D space. Its components are the <code>x</code>, <code>y</code>, and <code>z</code> components of the unit vector and can also be seen as the <code>u</code>, <code>v</code>, and <code>w</code> direction cosines of the direction identified by the <code>PointingVersor</code> instance.</p><p><strong>Fields</strong></p><ul><li><p><code>x::T</code>: The component along the X axis of the corresponding reference frame. Can also be accessed with the <code>u</code> property name.</p></li><li><p><code>y::T</code>: The component along the Y axis of the corresponding reference frame. Can also be accessed with the <code>v</code> property name.</p></li><li><p><code>z::T</code>: The component along the Z axis of the corresponding reference frame. Can also be accessed with the <code>w</code> property name.</p></li></ul><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.ElOverAz"><code>ElOverAz</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/pointing/types.jl#L1-L15" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.ThetaPhi" href="#SatcomCoordinates.ThetaPhi"><span class="jlbinding">SatcomCoordinates.ThetaPhi</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThetaPhi{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>An object specifying a pointing direction in ThetaPhi coordinates, defined as the θ and φ in the (ISO/Physics definition) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a></p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>θ</code> and <code>φ</code> angles is:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li><li><p><code>w = cos(θ)</code></p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>θ::Deg{T}</code>: The so-called <code>polar angle</code>, representing the angle between the <code>Z</code> axis and the <code>XY</code> plane of the reference frame. It is always normalized to fall within the [-90°, 90°] range.</p></li><li><p><code>φ::Deg{T}</code>: The so-called <code>azimuth angle</code>, representing the angle between the <code>y</code> and <code>x</code> component of the pointing direction. It is always normalized to fall within the [-180°, 180°] range.</p></li></ul><p>While the field name use the greek letters, the specific fields of an arbitrary <code>ThetaPhi</code> object <code>tp</code> can be accessed with alternative symbols:</p><ul><li><p><code>tp.θ</code>, <code>tp.theta</code> and <code>tp.t</code> can be used to access the <code>θ</code> field</p></li><li><p><code>tp.φ</code>, <code>tp.ϕ</code>, <code>tp.phi</code> and <code>tp.p</code> can be used to access the <code>φ</code> field</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(θ,φ)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>θ</code>, <code>φ</code> and instantiate the object. MarkdownAST.LineBreak()</p><p><strong>Provided inputs are intepreted as degrees if not provided using angular quantities from Unitful.</strong> If either of the inputs is <code>NaN</code>, the returned <code>ThetaPhi</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(tp)</span></span></code></pre></div><p>The <code>ThetaPhi</code> struct can be created using any 2-element Tuple or Vector/StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/pointing/types.jl#L64-L98" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.UV" href="#SatcomCoordinates.UV"><span class="jlbinding">SatcomCoordinates.UV</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UV{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T, 2}</span></span></code></pre></div><p>Specify a pointing direction in UV coordinates, which are equivalent to the direction cosines with respect to the <code>X</code> and <code>Y</code> axis of the reference frame. They can also be related to the spherical coordinates (ISO/Physics) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a> by the following equations:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>UV coordinates can only be used to represent pointing direction in the half-hemisphere containing the cartesian +Z axis.</p></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The inputs values must also satisfy <code>u^2 + v^2 &lt;= 1 + SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE[]</code> or an error will be thrown. The <code>SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE</code> is a <code>Ref{Float64}</code> which defaults to 1e-5 (In case <code>u^2 + v^2 &gt; 1</code> the inputs are normalized to ensure <code>u^2 + v^2 = 1</code>).</p></div><p><strong>Fields</strong></p><ul><li><p><code>u::T</code></p></li><li><p><code>v::T</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(u,v)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>u</code>, <code>v</code> and instantiate the object assuming that <code>u^2 + v^2 &lt;= 1</code> (condition for valid UV pointing), throwing an error otherwise. MarkdownAST.LineBreak()</p><p>If either of the inputs is <code>NaN</code>, the returned <code>UV</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(uv)</span></span></code></pre></div><p>The <code>UV{T}</code> can be created using any 2-element Tuple or StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/pointing/types.jl#L25-L56" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T&lt;:Union{AzOverEl, ElOverAz, ThetaPhi}" href="#SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T&lt;:Union{AzOverEl, ElOverAz, ThetaPhi}"><span class="jlbinding">SatcomCoordinates.wrap_spherical_angles</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><p>!!!</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/utils.jl#L37-L46" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block" open><summary><a id="SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{&lt;:Union{AzOverEl, ElOverAz}}}} where T&lt;:(Unitful.Quantity{&lt;:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})" href="#SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{&lt;:Union{AzOverEl, ElOverAz}}}} where T&lt;:(Unitful.Quantity{&lt;:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})"><span class="jlbinding">SatcomCoordinates.wrap_spherical_angles_normalized</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>This function already assumes that the provided input angles are already normalized such that both are in the [-180°, 180°] range. If you want to normalize the inputs automatically use the <code>wrap_first_angle</code> function.</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/319b4125c9061c481efff351425e1b91150ee903/src/utils.jl#L12-L22" target="_blank" rel="noreferrer">source</a></p></details></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/edit/main/docs/src/index.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><!----></div><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link next" href="/SatcomCoordinates.jl/dev/index" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Next page</span><span class="title" data-v-4f9813fa>Home</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://luxdl.github.io/DocumenterVitepress.jl/dev/" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br></p><p class="copyright" data-v-c970a860>© Copyright 2025.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DWV3ab6q\",\"performance.md\":\"FEENFT0X\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"SatcomCoordinates.jl\",\"description\":\"Documentation for SatcomCoordinates.jl\",\"base\":\"/SatcomCoordinates.jl/dev/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/index\"},{\"text\":\"Performance Examples\",\"link\":\"/performance\"},{\"component\":\"VersionPicker\"}],\"sidebar\":[{\"text\":\"Home\",\"link\":\"/index\"},{\"text\":\"Performance Examples\",\"link\":\"/performance\"}],\"editLink\":{\"pattern\":\"https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/edit/main/docs/src/:path\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/dev/\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br>\",\"copyright\":\"© Copyright 2025.\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>