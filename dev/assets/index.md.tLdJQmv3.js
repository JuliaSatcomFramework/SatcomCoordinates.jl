import{_ as n,C as l,c as r,o as p,j as s,a as i,ai as a,G as o}from"./chunks/framework.D-O0Ckvu.js";const he=JSON.parse('{"title":"SatcomCoordinates.jl","description":"","frontmatter":{},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),d={name:"index.md"},c={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},U={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},X={class:"jldocstring custom-block",open:""},Y={class:"jldocstring custom-block",open:""},Z={class:"jldocstring custom-block",open:""},W={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""},ee={class:"jldocstring custom-block",open:""},se={class:"jldocstring custom-block",open:""},ie={class:"jldocstring custom-block",open:""},te={class:"jldocstring custom-block",open:""},ae={class:"jldocstring custom-block",open:""};function oe(ne,e,le,re,pe,de){const t=l("Badge");return p(),r("div",null,[e[144]||(e[144]=s("h1",{id:"satcomcoordinates-jl",tabindex:"-1"},[i("SatcomCoordinates.jl "),s("a",{class:"header-anchor",href:"#satcomcoordinates-jl","aria-label":'Permalink to "SatcomCoordinates.jl"'},"​")],-1)),e[145]||(e[145]=s("p",null,[i("Documentation for "),s("code",null,"SatcomCoordinates.jl"),i(".")],-1)),s("details",c,[s("summary",null,[e[0]||(e[0]=s("a",{id:"SatcomCoordinates.ForwardOrInverse",href:"#SatcomCoordinates.ForwardOrInverse"},[s("span",{class:"jlbinding"},"SatcomCoordinates.ForwardOrInverse")],-1)),e[1]||(e[1]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[2]||(e[2]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardOrInverse{F </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSTransform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{F, InverseTransform{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span></span></code></pre></div><p>Union representing either a forward or reverse transform of F</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/type_aliases.jl#L41-L45" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",h,[s("summary",null,[e[3]||(e[3]=s("a",{id:"SatcomCoordinates.GenericLocalPosition",href:"#SatcomCoordinates.GenericLocalPosition"},[s("span",{class:"jlbinding"},"SatcomCoordinates.GenericLocalPosition")],-1)),e[4]||(e[4]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[5]||(e[5]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenericLocalPosition{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{LocalCartesian{T}, GeneralizedSpherical{T}}</span></span></code></pre></div><p>Union of all types that can represent a position in a generic local coordinate system.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/type_aliases.jl#L33-L37" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",k,[s("summary",null,[e[6]||(e[6]=s("a",{id:"SatcomCoordinates.GeocentricPosition",href:"#SatcomCoordinates.GeocentricPosition"},[s("span",{class:"jlbinding"},"SatcomCoordinates.GeocentricPosition")],-1)),e[7]||(e[7]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[8]||(e[8]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GeocentricPosition{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{ECEF{T}, ECI{T}, LLA{T}}</span></span></code></pre></div><p>Union of all types that can represent a position in the geocentric coordinate system.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/type_aliases.jl#L2-L6" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",g,[s("summary",null,[e[9]||(e[9]=s("a",{id:"SatcomCoordinates.TopocentricPosition",href:"#SatcomCoordinates.TopocentricPosition"},[s("span",{class:"jlbinding"},"SatcomCoordinates.TopocentricPosition")],-1)),e[10]||(e[10]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[11]||(e[11]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TopocentricPosition{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{ENU{T}, NED{T}, AER{T}}</span></span></code></pre></div><p>Union of all types that can represent a position in a topocentric coordinate system.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/type_aliases.jl#L10-L14" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",u,[s("summary",null,[e[12]||(e[12]=s("a",{id:"SatcomCoordinates.WithNumbertype",href:"#SatcomCoordinates.WithNumbertype"},[s("span",{class:"jlbinding"},"SatcomCoordinates.WithNumbertype")],-1)),e[13]||(e[13]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[14]||(e[14]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WithNumbertype{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{AbstractSatcomCoordinate{T}, AbstractCRSTransform{T}}</span></span></code></pre></div><p>Union representing the types defined and exported by this package, which always have a numbertype as first parameter.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/type_aliases.jl#L48-L52" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",b,[s("summary",null,[e[15]||(e[15]=s("a",{id:"SatcomCoordinates.AER",href:"#SatcomCoordinates.AER"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AER")],-1)),e[16]||(e[16]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[17]||(e[17]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AER{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngleAngleDistance{T}</span></span></code></pre></div><p>Represents a position in the Azimuth-Elevation-Range (AER) coordinate system, which is a local coordinate system centered at a point on or above the surface of an Ellipsoid. The Elevation and Azimuth angles are always defined w.r.t. the ENU CRS with the same origin. More specifically:</p><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}</code>: Azimuth angle, defined angle in the XY (North-East) plane from the +Y (North) direction to the object, positive towards +X (East) direction. It is constrained to be in the range <code>[-180°, 180°]</code></p></li><li><p><code>el::Deg{T}</code>: Elevation angle, defined as the angle between the XY plane and the point being described by the AER coordinates, positive towards +Z (Up) direction. It is constrained to be in the range <code>[-90°, 90°]</code></p></li><li><p><code>r::Met{T}</code>: Range in meters between the origin of the ENU CRS and the point being described by the AER coordinates.</p></li></ul><p>The fields of <code>AER</code> objects can also be accessed via <code>getproperty</code> using the follwing alternative aliases:</p><ul><li><p><code>azimuth</code> for <code>az</code></p></li><li><p><code>elevation</code> for <code>el</code></p></li><li><p><code>range</code> or <code>distance</code> for <code>r</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>AER(az::ValidAngle, el::ValidAngle, r::ValidDistance)</span></span></code></pre></div><p><code>ValidAngle</code> is either a Real Number, or a subtype of <code>Unitful.Angle</code>. <code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>AER</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.ENU"><code>ENU</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.NED"><code>NED</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/topocentric.jl#L72-L99" target="_blank" rel="noreferrer">source</a></p>',14))]),s("details",m,[s("summary",null,[e[18]||(e[18]=s("a",{id:"SatcomCoordinates.AbstractPointing",href:"#SatcomCoordinates.AbstractPointing"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AbstractPointing")],-1)),e[19]||(e[19]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[20]||(e[20]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractPointing{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, 3}</span></span></code></pre></div><p>Abstract type representing a pointing direction in 3 dimensions which is backed by fields with shared <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.numbertype"><code>numbertype</code></a> <code>T</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/abstract_types.jl#L36-L40" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",y,[s("summary",null,[e[21]||(e[21]=s("a",{id:"SatcomCoordinates.AbstractPointingOffset",href:"#SatcomCoordinates.AbstractPointingOffset"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AbstractPointingOffset")],-1)),e[22]||(e[22]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[23]||(e[23]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractPointingOffset{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, 2}</span></span></code></pre></div><p>Abstract type representing a pointing offset between two pointing directions.</p><p>Currently only has two concrete subtypes: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.UVOffset"><code>UVOffset</code></a> and <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.ThetaPhiOffset"><code>ThetaPhiOffset</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/abstract_types.jl#L51-L57" target="_blank" rel="noreferrer">source</a></p>',4))]),s("details",f,[s("summary",null,[e[24]||(e[24]=s("a",{id:"SatcomCoordinates.AbstractSatcomCoordinate",href:"#SatcomCoordinates.AbstractSatcomCoordinate"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AbstractSatcomCoordinate")],-1)),e[25]||(e[25]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[26]||(e[26]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>General abstract type identifying a <em>coordinate</em> with <code>N</code> dimensions and an underlying number type <code>T</code>. The number type <code>T</code> is not necessarily the type of the fields in the type instance, but their underlying real type (this is only different for fields whose types are Unitful quantities, where <code>numbertype(::Quantity{T}) where T = T</code>).</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The term <em>coordinate</em> is used here in a loose sense, identifying both position in space as well as pointing directions</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/abstract_types.jl#L1-L8" target="_blank" rel="noreferrer">source</a></p>',4))]),s("details",C,[s("summary",null,[e[27]||(e[27]=s("a",{id:"SatcomCoordinates.AngleAngleDistance",href:"#SatcomCoordinates.AngleAngleDistance"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AngleAngleDistance")],-1)),e[28]||(e[28]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[29]||(e[29]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AngleAngleDistance{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, 3}</span></span></code></pre></div><p>Abstract type representing a position in 3 dimensions, identified by two angles and a distance.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/abstract_types.jl#L13-L17" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",E,[s("summary",null,[e[30]||(e[30]=s("a",{id:"SatcomCoordinates.AngularPointing",href:"#SatcomCoordinates.AngularPointing"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AngularPointing")],-1)),e[31]||(e[31]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[32]||(e[32]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AngularPointing{T}</span></span></code></pre></div><p>Abstract type representing a pointing direction identified by two angles in degrees, represented with fields of types <code>Deg{T}</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/abstract_types.jl#L43-L48" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",T,[s("summary",null,[e[33]||(e[33]=s("a",{id:"SatcomCoordinates.AzEl",href:"#SatcomCoordinates.AzEl"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AzEl")],-1)),e[34]||(e[34]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[35]||(e[35]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AzEl{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Elevation/Azimuth&quot; coordinates, defined following the convention used for Azimuth-Elevation-Range (<a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AER"><code>AER</code></a>) coordinates used by MATLAB and by this package.</p><p>This represents the azimuth/elevation definition often used for describing pointing from a user terminal on ground towards a satellite. They are very similar to the <code>ElOverAz</code> definition but with a rotation of the underlying CRS such that elevation is 90° in the direction of the +Z axis and azimuth is computed on the XY plane from the +Y axis towards the +X axis.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>El</code> and <code>Az</code> angles is:</p><ul><li><p><code>u = cos(El) * sin(Az)</code></p></li><li><p><code>v = cos(El) * cos(Az)</code></p></li><li><p><code>w = sin(El)</code></p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The fields of <code>AzEl</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p></div><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ElOverAz"><code>ElOverAz</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#AzOverEl"><code>AzOverEl</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/pointing.jl#L167-L187" target="_blank" rel="noreferrer">source</a></p>',10))]),s("details",_,[s("summary",null,[e[36]||(e[36]=s("a",{id:"SatcomCoordinates.AzElDistance",href:"#SatcomCoordinates.AzElDistance"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AzElDistance")],-1)),e[37]||(e[37]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[38]||(e[38]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AzElDistance{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GeneralizedSpherical{T, AzEl{T}}</span></span></code></pre></div><p>Type representing a position w.r.t. a local CRS in Azimuth, Elevation and Range coordinates. The difference between <code>AzElDistance</code> and <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AER"><code>AER</code></a> is that <code>AER</code> is a always referred to the ENU CRS, while <code>AzElDistance</code> is for a generic local CRS.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/type_aliases.jl#L25-L30" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",S,[s("summary",null,[e[39]||(e[39]=s("a",{id:"SatcomCoordinates.AzOverEl",href:"#SatcomCoordinates.AzOverEl"},[s("span",{class:"jlbinding"},"SatcomCoordinates.AzOverEl")],-1)),e[40]||(e[40]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[41]||(e[41]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AzOverEl{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Azimuth over Elevation&quot; coordinates, which specify the elevation and azimuth angles that needs to be fed to an azimuth-over-elevation positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>Az</code> and <code>El</code> angles is:</p><ul><li><p><code>u = -sin(Az)</code></p></li><li><p><code>v = cos(Az) * sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The equations above are used to represent the &quot;Azimuth over Elevation&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with a possible flip in the az/u sign) are used to describe an &quot;Elevation over Azimuth&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p></div><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The fields of <code>AzOverEl</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/pointing.jl#L106-L127" target="_blank" rel="noreferrer">source</a></p>',10))]),s("details",v,[s("summary",null,[e[42]||(e[42]=s("a",{id:"SatcomCoordinates.BasicCRSTransform",href:"#SatcomCoordinates.BasicCRSTransform"},[s("span",{class:"jlbinding"},"SatcomCoordinates.BasicCRSTransform")],-1)),e[43]||(e[43]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[44]||(e[44]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BasicCRSTransform{T, R </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Union{CRSRotation{T}, Identity}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, O </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianPosition{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSTransform{T}</span></span></code></pre></div><p>A type representing a basic transformation (rotation + translation).</p><p><strong>Fields:</strong></p><ul><li><p><code>rotation::R</code>: The rotation of the transformation.</p></li><li><p><code>origin::O</code>: The origin of the transformation.</p></li></ul><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/transforms.jl#L21-L29" target="_blank" rel="noreferrer">source</a></p>',5))]),s("details",A,[s("summary",null,[e[45]||(e[45]=s("a",{id:"SatcomCoordinates.CRSRotation",href:"#SatcomCoordinates.CRSRotation"},[s("span",{class:"jlbinding"},"SatcomCoordinates.CRSRotation")],-1)),e[46]||(e[46]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[47]||(e[47]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CRSRotation{T, R </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> StaticMatrix{T, 3, 3}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSRotation{T}</span></span></code></pre></div><p>A type representing a basic rotation of a coordinate system.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/transforms.jl#L12-L16" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",j,[s("summary",null,[e[48]||(e[48]=s("a",{id:"SatcomCoordinates.CartesianPosition",href:"#SatcomCoordinates.CartesianPosition"},[s("span",{class:"jlbinding"},"SatcomCoordinates.CartesianPosition")],-1)),e[49]||(e[49]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[50]||(e[50]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CartesianPosition{T, N} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>Abstract type representing a coordinate in <code>N</code> dimensions which is backed by fields all of type <code>T</code>. Concrete subtypes of this are subtypes of <code>FieldVector</code></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/abstract_types.jl#L20-L26" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",F,[s("summary",null,[e[51]||(e[51]=s("a",{id:"SatcomCoordinates.ECEF",href:"#SatcomCoordinates.ECEF"},[s("span",{class:"jlbinding"},"SatcomCoordinates.ECEF")],-1)),e[52]||(e[52]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[53]||(e[53]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ECEF{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the Earth-Centered, Earth-Fixed (ECEF) coordinate system (or generically for other planets, Ellipsoid-Centered, Ellipsoid-Fixed).</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ECEF(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>ECEF</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECI"><code>ECI</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#LLA"><code>LLA</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/geocentric.jl#L1-L22" target="_blank" rel="noreferrer">source</a></p>',12))]),s("details",D,[s("summary",null,[e[54]||(e[54]=s("a",{id:"SatcomCoordinates.ECI",href:"#SatcomCoordinates.ECI"},[s("span",{class:"jlbinding"},"SatcomCoordinates.ECI")],-1)),e[55]||(e[55]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[56]||(e[56]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ECI{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the Earth-Centered, Inertial (ECI) coordinate system (or generically for other planets, Ellipsoid-Centered, Inertial).</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ECI(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>ECI</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECEF"><code>ECEF</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#LLA"><code>LLA</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/geocentric.jl#L31-L52" target="_blank" rel="noreferrer">source</a></p>',12))]),s("details",P,[s("summary",null,[e[57]||(e[57]=s("a",{id:"SatcomCoordinates.ENU",href:"#SatcomCoordinates.ENU"},[s("span",{class:"jlbinding"},"SatcomCoordinates.ENU")],-1)),e[58]||(e[58]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[59]||(e[59]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ENU{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the East-North-Up (ENU) coordinate system, which is a local coordinate system centered at a point on or above the surface of an Ellipsoid. The direction of the ENU axes is uniquely determined by the latitude, longitude, and altitude of the point w.r.t. the referenced ellipsoid.</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p>The fields of <code>ENU</code> objects can also be accessed via <code>getproperty</code> using the follwing alternative aliases:</p><ul><li><p><code>east</code> for <code>x</code></p></li><li><p><code>north</code> for <code>y</code></p></li><li><p><code>up</code> for <code>z</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ENU(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>ENU</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.NED"><code>NED</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AER"><code>AER</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/topocentric.jl#L1-L28" target="_blank" rel="noreferrer">source</a></p>',14))]),s("details",w,[s("summary",null,[e[60]||(e[60]=s("a",{id:"SatcomCoordinates.ElOverAz",href:"#SatcomCoordinates.ElOverAz"},[s("span",{class:"jlbinding"},"SatcomCoordinates.ElOverAz")],-1)),e[61]||(e[61]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[62]||(e[62]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ElOverAz{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Elevation over Azimuth&quot; coordinates, which specify the azimuth and elevation angles that needs to be fed to an elevation-over-azimuth positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>El</code> and <code>Az</code> angles is:</p><ul><li><p><code>u = -sin(Az) * cos(El)</code></p></li><li><p><code>v = sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The equations above are used to represent the &quot;Elevation over Azimuth&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with sometimes an additional flip in the az/u sign) are used to describe an &quot;Azimuth over Elevation&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p></div><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The fields of <code>ElOverAz</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p></div><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/pointing.jl#L136-L159" target="_blank" rel="noreferrer">source</a></p>',11))]),s("details",x,[s("summary",null,[e[63]||(e[63]=s("a",{id:"SatcomCoordinates.GeneralizedSpherical",href:"#SatcomCoordinates.GeneralizedSpherical"},[s("span",{class:"jlbinding"},"SatcomCoordinates.GeneralizedSpherical")],-1)),e[64]||(e[64]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[65]||(e[65]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GeneralizedSpherical{T, P </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngleAngleDistance{T}</span></span></code></pre></div><p>Represents a position in a local CRS, defined by an angular pointing direction and a distance.</p><p><strong>Fields</strong></p><ul><li><p><code>pointing::P</code>: The pointing direction of the object</p></li><li><p><code>r::Met{T}</code>: The distance of the object from the origin of the CRS</p></li></ul><p>The <code>r</code> field can also be accessed via <code>getproperty</code> using the <code>distance</code> alias:</p><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PointingAndDistance(pointing::P, r::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>PointingAndDistance</code> object will contain <code>NaN</code> for all fields.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.Spherical"><code>Spherical</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AzElDistance"><code>AzElDistance</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.LocalCartesian"><code>LocalCartesian</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/local.jl#L32-L50" target="_blank" rel="noreferrer">source</a></p>',11))]),s("details",N,[s("summary",null,[e[66]||(e[66]=s("a",{id:"SatcomCoordinates.InverseTransform",href:"#SatcomCoordinates.InverseTransform"},[s("span",{class:"jlbinding"},"SatcomCoordinates.InverseTransform")],-1)),e[67]||(e[67]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[68]||(e[68]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InverseTransform{T, F </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSTransform{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractCRSTransform{T}</span></span></code></pre></div><p>A type representing an inverse of an <a href="./@ref"><code>AbstractCRSTransform</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/transforms.jl#L1-L5" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",V,[s("summary",null,[e[69]||(e[69]=s("a",{id:"SatcomCoordinates.LLA",href:"#SatcomCoordinates.LLA"},[s("span",{class:"jlbinding"},"SatcomCoordinates.LLA")],-1)),e[70]||(e[70]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[71]||(e[71]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LLA{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngleAngleDistance{T}</span></span></code></pre></div><p>Identify a point on or above earth using geodetic coordinates</p><p><strong>Fields</strong></p><ul><li><p><code>lat::Deg{T}</code>: Latitude of the point in degrees [-90°, 90°]</p></li><li><p><code>lon::Deg{T}</code>: Longitude of the point in degrees [-180°, 180°]</p></li><li><p><code>alt::Met{T}</code>: Altitude of the point above the reference ellipsoid</p></li></ul><p>The fields of <code>LLA</code> objects can also be accessed via <code>getproperty</code> using the follwing alternative aliases:</p><ul><li><p><code>latitude</code> for <code>lat</code></p></li><li><p><code>longitude</code> for <code>lon</code></p></li><li><p><code>altitude</code>, <code>h</code> or <code>height</code> for <code>alt</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LLA(lat::ValidAngle,lon::ValidAngle,alt::ValidDistance)</span></span>
<span class="line"><span>LLA(lat::ValidAngle,lon::ValidAngle) # Defaults to 0m altitude</span></span></code></pre></div><p><code>ValidAngle</code> is a either a Real number or a <code>Unitful.Quantity</code> of unit either <code>u&quot;rad&quot;</code> or <code>u&quot;°&quot;</code>.</p><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>LLA</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECEF"><code>ECEF</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ECI"><code>ECI</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/geocentric.jl#L61-L91" target="_blank" rel="noreferrer">source</a></p>`,15))]),s("details",U,[s("summary",null,[e[72]||(e[72]=s("a",{id:"SatcomCoordinates.LengthCartesian",href:"#SatcomCoordinates.LengthCartesian"},[s("span",{class:"jlbinding"},"SatcomCoordinates.LengthCartesian")],-1)),e[73]||(e[73]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[74]||(e[74]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LengthCartesian{T, N} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianPosition{T, N}</span></span></code></pre></div><p>Abstract type representing a coordinate in <code>N</code> dimensions which is backed by fields all of type <code>Met{T}</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/abstract_types.jl#L29-L33" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",R,[s("summary",null,[e[75]||(e[75]=s("a",{id:"SatcomCoordinates.LocalCartesian",href:"#SatcomCoordinates.LocalCartesian"},[s("span",{class:"jlbinding"},"SatcomCoordinates.LocalCartesian")],-1)),e[76]||(e[76]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[77]||(e[77]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LocalCartesian{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in a generic local CRS.</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalCartesian(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>LocalCartesian</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.GeneralizedSpherical"><code>GeneralizedSpherical</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/local.jl#L1-L22" target="_blank" rel="noreferrer">source</a></p>',12))]),s("details",L,[s("summary",null,[e[78]||(e[78]=s("a",{id:"SatcomCoordinates.NED",href:"#SatcomCoordinates.NED"},[s("span",{class:"jlbinding"},"SatcomCoordinates.NED")],-1)),e[79]||(e[79]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[80]||(e[80]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NED{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the North-East-Down (NED) coordinate system, which is a local coordinate system centered at a point on or above the surface of an Ellipsoid. The direction of the NED axes is uniquely determined by the latitude, longitude, and altitude of the point w.r.t. the referenced ellipsoid.</p><p><strong>Fields</strong></p><ul><li><p><code>x::Met{T}</code>: X-coordinate in meters</p></li><li><p><code>y::Met{T}</code>: Y-coordinate in meters</p></li><li><p><code>z::Met{T}</code>: Z-coordinate in meters</p></li></ul><p>The fields of <code>NED</code> objects can also be accessed via <code>getproperty</code> using the follwing alternative aliases:</p><ul><li><p><code>north</code> for <code>x</code></p></li><li><p><code>east</code> for <code>y</code></p></li><li><p><code>down</code> for <code>z</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>NED(x::ValidDistance, y::ValidDistance, z::ValidDistance)</span></span></code></pre></div><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>NED</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.ENU"><code>ENU</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AER"><code>AER</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/topocentric.jl#L37-L64" target="_blank" rel="noreferrer">source</a></p>',14))]),s("details",I,[s("summary",null,[e[81]||(e[81]=s("a",{id:"SatcomCoordinates.PointingVersor",href:"#SatcomCoordinates.PointingVersor"},[s("span",{class:"jlbinding"},"SatcomCoordinates.PointingVersor")],-1)),e[82]||(e[82]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[83]||(e[83]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PointingVersor{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T}</span></span></code></pre></div><p>A unit vector (versor) representing a pointing direction in 3D space. Its components are the <code>x</code>, <code>y</code>, and <code>z</code> components of the unit vector and can also be seen as the <code>u</code>, <code>v</code>, and <code>w</code> direction cosines of the direction identified by the <code>PointingVersor</code> instance.</p><p><strong>Fields</strong></p><ul><li><p><code>x::T</code>: The component along the X axis of the corresponding reference frame. Can also be accessed with the <code>u</code> property name.</p></li><li><p><code>y::T</code>: The component along the Y axis of the corresponding reference frame. Can also be accessed with the <code>v</code> property name.</p></li><li><p><code>z::T</code>: The component along the Z axis of the corresponding reference frame. Can also be accessed with the <code>w</code> property name.</p></li></ul><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ElOverAz"><code>ElOverAz</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/pointing.jl#L1-L15" target="_blank" rel="noreferrer">source</a></p>',6))]),s("details",O,[s("summary",null,[e[84]||(e[84]=s("a",{id:"SatcomCoordinates.Spherical",href:"#SatcomCoordinates.Spherical"},[s("span",{class:"jlbinding"},"SatcomCoordinates.Spherical")],-1)),e[85]||(e[85]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[86]||(e[86]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spherical{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GeneralizedSpherical{T, ThetaPhi{T}}</span></span></code></pre></div><p>Type representing a position in ISO/Physics spherical coordinates</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/type_aliases.jl#L18-L22" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",z,[s("summary",null,[e[87]||(e[87]=s("a",{id:"SatcomCoordinates.ThetaPhi",href:"#SatcomCoordinates.ThetaPhi"},[s("span",{class:"jlbinding"},"SatcomCoordinates.ThetaPhi")],-1)),e[88]||(e[88]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[89]||(e[89]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThetaPhi{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>An object specifying a pointing direction in ThetaPhi coordinates, defined as the θ and φ in the (ISO/Physics definition) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a></p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>θ</code> and <code>φ</code> angles is:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li><li><p><code>w = cos(θ)</code></p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>θ::Deg{T}</code>: The so-called <code>polar angle</code>, representing the angle between the <code>Z</code> axis and the <code>XY</code> plane of the reference frame. It is always normalized to fall within the [-90°, 90°] range.</p></li><li><p><code>φ::Deg{T}</code>: The so-called <code>azimuth angle</code>, representing the angle between the <code>y</code> and <code>x</code> component of the pointing direction. It is always normalized to fall within the [-180°, 180°] range.</p></li></ul><p>While the field name use the greek letters, the specific fields of an arbitrary <code>ThetaPhi</code> object <code>tp</code> can be accessed with alternative symbols:</p><ul><li><p><code>tp.θ</code>, <code>tp.theta</code> and <code>tp.t</code> can be used to access the <code>θ</code> field</p></li><li><p><code>tp.φ</code>, <code>tp.ϕ</code>, <code>tp.phi</code> and <code>tp.p</code> can be used to access the <code>φ</code> field</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(θ,φ)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>θ</code>, <code>φ</code> and instantiate the object. MarkdownAST.LineBreak()</p><p><strong>Provided inputs are intepreted as degrees if not provided using angular quantities from Unitful.</strong> If either of the inputs is <code>NaN</code>, the returned <code>ThetaPhi</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(tp)</span></span></code></pre></div><p>The <code>ThetaPhi</code> struct can be created using any 2-element Tuple or Vector/StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/pointing.jl#L64-L98" target="_blank" rel="noreferrer">source</a></p>',16))]),s("details",B,[s("summary",null,[e[90]||(e[90]=s("a",{id:"SatcomCoordinates.ThetaPhiOffset",href:"#SatcomCoordinates.ThetaPhiOffset"},[s("span",{class:"jlbinding"},"SatcomCoordinates.ThetaPhiOffset")],-1)),e[91]||(e[91]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[92]||(e[92]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThetaPhiOffset{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointingOffset{T}</span></span></code></pre></div><p>Type used to describe an angular offset between two pointing directions.</p><p>The ThetaPhiOffset coordinates must satisfy:</p><ul><li><p><code>theta ∈ [-90, 90]</code></p></li><li><p><code>phi ∈ [-180, 180]</code></p></li></ul><p>This type is mostly used with the <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a> and <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a> functions.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/pointing_offsets.jl#L24-L34" target="_blank" rel="noreferrer">source</a></p>',6))]),s("details",M,[s("summary",null,[e[93]||(e[93]=s("a",{id:"SatcomCoordinates.UV",href:"#SatcomCoordinates.UV"},[s("span",{class:"jlbinding"},"SatcomCoordinates.UV")],-1)),e[94]||(e[94]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[95]||(e[95]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UV{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T}</span></span></code></pre></div><p>Specify a pointing direction in UV coordinates, which are equivalent to the direction cosines with respect to the <code>X</code> and <code>Y</code> axis of the reference frame. They can also be related to the spherical coordinates (ISO/Physics) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a> by the following equations:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>UV coordinates can only be used to represent pointing direction in the half-hemisphere containing the cartesian +Z axis.</p></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The inputs values must also satisfy <code>u^2 + v^2 &lt;= 1 + SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE[]</code> or an error will be thrown. The <code>SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE</code> is a <code>Ref{Float64}</code> which defaults to 1e-5 (In case <code>u^2 + v^2 &gt; 1</code> the inputs are normalized to ensure <code>u^2 + v^2 = 1</code>).</p></div><p><strong>Fields</strong></p><ul><li><p><code>u::T</code></p></li><li><p><code>v::T</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(u,v)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>u</code>, <code>v</code> and instantiate the object assuming that <code>u^2 + v^2 &lt;= 1</code> (condition for valid UV pointing), throwing an error otherwise. MarkdownAST.LineBreak()</p><p>If either of the inputs is <code>NaN</code>, the returned <code>UV</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(uv)</span></span></code></pre></div><p>The <code>UV{T}</code> can be created using any 2-element Tuple or StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/pointing.jl#L25-L56" target="_blank" rel="noreferrer">source</a></p>',15))]),s("details",J,[s("summary",null,[e[96]||(e[96]=s("a",{id:"SatcomCoordinates.UVOffset",href:"#SatcomCoordinates.UVOffset"},[s("span",{class:"jlbinding"},"SatcomCoordinates.UVOffset")],-1)),e[97]||(e[97]=i()),o(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[98]||(e[98]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UVOffset{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointingOffset{T}</span></span></code></pre></div><p>Type used to describe an offset in UV coordinates.</p><p>The UVOffset coordinates must satisfy:</p><ul><li><code>sqrt(u^2 + v^2) ≤ 2</code></li></ul><p>This type is mostly generated indirectly when subtracting two pointing directions expressed in UV.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/types/pointing_offsets.jl#L1-L10" target="_blank" rel="noreferrer">source</a></p>',6))]),s("details",q,[s("summary",null,[e[99]||(e[99]=s("a",{id:"SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O<:AbstractPointing, P<:AbstractPointing}",href:"#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O<:AbstractPointing, P<:AbstractPointing}"},[s("span",{class:"jlbinding"},"SatcomCoordinates.add_angular_offset")],-1)),e[100]||(e[100]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[101]||(e[101]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₀</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, offset_angles</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{ThetaPhi, ThetaPhiOffset}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₀</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointingType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output_type, p₀, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the resulting pointing direction <code>p</code> obtained by adding an angular offset expressed as θ and φ angles (following the ISO/Physics convention for spherical coordinates) [deg] to the starting position identified by <code>p₀</code>.</p><p>The input starting position <code>p₀</code> must be any subtype of <code>AbstractPointing</code> The input <code>offset_angles</code> can be provided as an instance of one of the following types:</p><ul><li><p><code>ThetaPhi</code></p></li><li><p><code>ThetaPhiOffset</code></p></li></ul><p>and is converted to <code>ThetaPhiOffset</code> internally, with non-unitful values being interpreted as angles in degrees.</p><p>The output is of type <code>output_type</code> if provided or of the same type as <code>p₀</code> otherwise.</p><p><strong>Note</strong></p><p>If <code>output_type</code> is <code>UV</code>, the function will throw an error if the final pointing direction is located behind the viewer as the output in UV would be ambiguous. This is not the case for other subtypes of <code>AbstractPointing</code> so an explicit output type (different from <code>UV</code>) should be provided if the target is expected to be behind the viewer.</p><p>The offset angles can also be provided separately as 2nd and 3rd argument (optional, defaults to 0.0) to the function using the second method signature. In this case, the inputs are treated as angles in degrees unless explicitly provided using quantitites with <code>°</code> unit from the Unitful package.</p><p>This function performs the inverse operation of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a> so the following code should return true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SatcomCoordinates</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, offset)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv2</span></span></code></pre></div><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_distance</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/functions/pointing_offsets.jl#L164-L202" target="_blank" rel="noreferrer">source</a></p>`,13))]),s("details",G,[s("summary",null,[e[102]||(e[102]=s("a",{id:"SatcomCoordinates.angle_offset_rotation-Tuple{Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T}",href:"#SatcomCoordinates.angle_offset_rotation-Tuple{Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T}"},[s("span",{class:"jlbinding"},"SatcomCoordinates.angle_offset_rotation")],-1)),e[103]||(e[103]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[104]||(e[104]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">angle_offset_rotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ, φ)</span></span></code></pre></div><p>Compute the rotation matrix to find offset points following the procedure in this stackexchnge answer: <a href="https://math.stackexchange.com/questions/4343044/rotate-vector-by-a-random-little-amount" target="_blank" rel="noreferrer">https://math.stackexchange.com/questions/4343044/rotate-vector-by-a-random-little-amount</a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/functions/pointing_offsets.jl#L75-L81" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",Q,[s("summary",null,[e[105]||(e[105]=s("a",{id:"SatcomCoordinates.change_numbertype",href:"#SatcomCoordinates.change_numbertype"},[s("span",{class:"jlbinding"},"SatcomCoordinates.change_numbertype")],-1)),e[106]||(e[106]=i()),o(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[107]||(e[107]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">change_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x)</span></span></code></pre></div><p>Functions that change the underlying numbertype of the provided object <code>x</code> to the first argument <code>T</code>.</p><p>It has a fallback default implementation for types defined within this package which calls <code>convert</code> on the provided object <code>x</code> to the type <code>basetype(x){T}</code>.</p><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.numbertype"><code>numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.enforce_numbertype"><code>enforce_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.has_numbertype"><code>has_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N"><code>default_numbertype</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L45-L53" target="_blank" rel="noreferrer">source</a></p>',5))]),s("details",X,[s("summary",null,[e[108]||(e[108]=s("a",{id:"SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N",href:"#SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N"},[s("span",{class:"jlbinding"},"SatcomCoordinates.default_numbertype")],-1)),e[109]||(e[109]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[110]||(e[110]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">default_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Function that returns the common valid numbertype among the arguments provided as input. It finds the common numbertype via <code>promote_type</code> and either return that (if it&#39;s a subtype of <code>AbstractFloat</code>) or <code>Float64</code> if it&#39;s not.</p><p>This function is useful to automatically extract from inputs the <code>numbertype</code> to use in constructors.</p><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.numbertype"><code>numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.enforce_numbertype"><code>enforce_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.has_numbertype"><code>has_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.change_numbertype"><code>change_numbertype</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L56-L64" target="_blank" rel="noreferrer">source</a></p>',5))]),s("details",Y,[s("summary",null,[e[111]||(e[111]=s("a",{id:"SatcomCoordinates.enforce_numbertype",href:"#SatcomCoordinates.enforce_numbertype"},[s("span",{class:"jlbinding"},"SatcomCoordinates.enforce_numbertype")],-1)),e[112]||(e[112]=i()),o(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[113]||(e[113]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input_type, [default_numbertype]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {C </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Union{AbstractSatcomCoordinate, AbstractCRSTransform}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Function that takes as input a type and returns a potentialy more specialized subtype of the input type with the numbertype parameter set if not specified in <code>input_type</code>. Optionally, this function accepts a secon type (or value) as argument and infers the numbertype to set as default (if not alredy present). The default numbertype when the function is called with 1-argument is <code>Float64</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV{Float64} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Provide a default as not present in input type</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV{Float32}) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV{Float32} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Returns the same input type as it already has a numbertype</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV, Float32) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV{Float32} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Provide a custom default as not present in input type</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enforce_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV{Int64} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Provide a custom default as not present in input type</span></span></code></pre></div><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.numbertype"><code>numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.enforce_numbertype"><code>enforce_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.has_numbertype"><code>has_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N"><code>default_numbertype</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L27-L42" target="_blank" rel="noreferrer">source</a></p>`,6))]),s("details",Z,[s("summary",null,[e[114]||(e[114]=s("a",{id:"SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}",href:"#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"},[s("span",{class:"jlbinding"},"SatcomCoordinates.get_angular_distance")],-1)),e[115]||(e[115]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[116]||(e[116]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_angular_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₁</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p₂</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the angular distance [°] between the target pointing direction <code>p₂</code> and the starting pointing direction <code>p₁</code>.</p><p><strong>Note</strong></p><p>This function&#39;s output should be approximately equivalent to the θ (theta) component of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a> but has a faster implementation. Use this in case the φ (phi) component is not required and speed is important. The following code should evaluate to true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SatcomCoordinates</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Δθ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">theta </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Δθ</span></span></code></pre></div><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/functions/pointing_offsets.jl#L47-L68" target="_blank" rel="noreferrer">source</a></p>`,7))]),s("details",W,[s("summary",null,[e[117]||(e[117]=s("a",{id:"SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}",href:"#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"},[s("span",{class:"jlbinding"},"SatcomCoordinates.get_angular_offset")],-1)),e[118]||(e[118]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[119]||(e[119]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₁</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p₂</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThetaPhiOffset</span></span></code></pre></div><p>Compute the angular offset required to reach the target pointing direction <code>p₂</code> from starting pointing direction <code>p₁</code>. The two input pointings can be of any valid <code>AbstractPointing</code> type.</p><p>The output is of type <code>ThetaPhiOffset</code></p><p><strong>Note</strong></p><p>This function performs the inverse operation of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a> so the following code should return true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReferenceViews</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, offset)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv2</span></span></code></pre></div><p>Check out <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_distance</code></a> for a slightly faster implementation in case you only require the angular distance rather than the 2D offset.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/functions/pointing_offsets.jl#L124-L149" target="_blank" rel="noreferrer">source</a></p>`,9))]),s("details",$,[s("summary",null,[e[120]||(e[120]=s("a",{id:"SatcomCoordinates.has_numbertype",href:"#SatcomCoordinates.has_numbertype"},[s("span",{class:"jlbinding"},"SatcomCoordinates.has_numbertype")],-1)),e[121]||(e[121]=i()),o(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[122]||(e[122]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">has_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">has_numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This function shall return <code>true</code> if the provided type <code>T</code> or object of type <code>T</code> has an associated numbertype.</p><p>This function will return <code>false</code> for types defined within this package that do not have the numbertype parameter specified (type <code>T</code> is thus a <code>UnionAll</code> on the numbertype parameter).</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L17-L24" target="_blank" rel="noreferrer">source</a></p>`,4))]),s("details",H,[s("summary",null,[e[123]||(e[123]=s("a",{id:"SatcomCoordinates.numbertype",href:"#SatcomCoordinates.numbertype"},[s("span",{class:"jlbinding"},"SatcomCoordinates.numbertype")],-1)),e[124]||(e[124]=i()),o(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[125]||(e[125]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numbertype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This function shall return the underlying numbertype of the provided Type or object.</p><p>The concept of numbertype is defined here as the subtype of <code>Real</code> which is used to represent the numerical values in the object&#39;s field. It is not directly the type of the fields, mainly as we consider fields of type <code>Unitul.Quantity{T}</code> to have numbertype <code>T</code>.</p><p>All the types defined in this package have an assciated parametric numbertype as first parameter.</p><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.enforce_numbertype"><code>enforce_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.change_numbertype"><code>change_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.has_numbertype"><code>has_numbertype</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.default_numbertype-Union{NTuple{N, Any}, Tuple{N}} where N"><code>default_numbertype</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L2-L14" target="_blank" rel="noreferrer">source</a></p>`,6))]),s("details",K,[s("summary",null,[e[126]||(e[126]=s("a",{id:"SatcomCoordinates.origin-Tuple{SatcomCoordinates.AbstractAffineCRSTransform}",href:"#SatcomCoordinates.origin-Tuple{SatcomCoordinates.AbstractAffineCRSTransform}"},[s("span",{class:"jlbinding"},"SatcomCoordinates.origin")],-1)),e[127]||(e[127]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[128]||(e[128]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">origin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractAffineCRSTransform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This function should return an object which is subtype of <code>CartesianPosition</code> and represents the origin of the starting CRS in the target CRS.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/functions/transforms.jl#L11-L15" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",ee,[s("summary",null,[e[129]||(e[129]=s("a",{id:"SatcomCoordinates.raw_nt-Tuple{C} where C<:AbstractSatcomCoordinate",href:"#SatcomCoordinates.raw_nt-Tuple{C} where C<:AbstractSatcomCoordinate"},[s("span",{class:"jlbinding"},"SatcomCoordinates.raw_nt")],-1)),e[130]||(e[130]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[131]||(e[131]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">raw_nt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSatcomCoordinate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generated a NamedTuple from the provided Object which has the same names as the object fields but contains <em>normalized</em> values of its fields</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>By <em>normalized</em> we mean that fields containing Uniftul quantities are stripped of their units and in the case of <code>Deg</code> fields, they are converted to radians as trig functions are faster for radians inputs.</p></div><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.to_svector-Tuple{C} where C&lt;:AbstractSatcomCoordinate"><code>to_svector</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L124-L132" target="_blank" rel="noreferrer">source</a></p>',5))]),s("details",se,[s("summary",null,[e[132]||(e[132]=s("a",{id:"SatcomCoordinates.rotation-Tuple{CRSRotation}",href:"#SatcomCoordinates.rotation-Tuple{CRSRotation}"},[s("span",{class:"jlbinding"},"SatcomCoordinates.rotation")],-1)),e[133]||(e[133]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[134]||(e[134]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractAffineCRSTransform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This function should return a <code>CRSRotation</code> object representing the rotation to align the starting CRS to the target CRS.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/functions/transforms.jl#L19-L23" target="_blank" rel="noreferrer">source</a></p>',3))]),s("details",ie,[s("summary",null,[e[135]||(e[135]=s("a",{id:"SatcomCoordinates.to_svector-Tuple{C} where C<:AbstractSatcomCoordinate",href:"#SatcomCoordinates.to_svector-Tuple{C} where C<:AbstractSatcomCoordinate"},[s("span",{class:"jlbinding"},"SatcomCoordinates.to_svector")],-1)),e[136]||(e[136]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[137]||(e[137]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">to_svector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coord</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSatcomCoordinate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate the unitless SVector containing the <em>normalized</em> fields of the provided coordinate.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>By <em>normalized</em> we mean that fields containing Uniftul quantities are stripped of their units and in the case of <code>Deg</code> fields, they are converted to radians as trig functions are faster for radians inputs.</p></div><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.raw_nt-Tuple{C} where C&lt;:AbstractSatcomCoordinate"><code>raw_nt</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L110-L119" target="_blank" rel="noreferrer">source</a></p>',5))]),s("details",te,[s("summary",null,[e[138]||(e[138]=s("a",{id:"SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T<:Union{AzOverEl, ElOverAz, ThetaPhi}",href:"#SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T<:Union{AzOverEl, ElOverAz, ThetaPhi}"},[s("span",{class:"jlbinding"},"SatcomCoordinates.wrap_spherical_angles")],-1)),e[139]||(e[139]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[140]||(e[140]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><p>!!!</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L97-L106" target="_blank" rel="noreferrer">source</a></p>`,5))]),s("details",ae,[s("summary",null,[e[141]||(e[141]=s("a",{id:"SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{<:Union{AER, AzEl, AzOverEl, ElOverAz}}}} where T<:(Unitful.Quantity{<:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})",href:"#SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{<:Union{AER, AzEl, AzOverEl, ElOverAz}}}} where T<:(Unitful.Quantity{<:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})"},[s("span",{class:"jlbinding"},"SatcomCoordinates.wrap_spherical_angles_normalized")],-1)),e[142]||(e[142]=i()),o(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[143]||(e[143]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>This function already assumes that the provided input angles are already normalized such that both are in the [-180°, 180°] range. If you want to normalize the inputs automatically use the <code>wrap_first_angle</code> function.</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/80588b69cc0c1c861cd947735bc532baf145c0c7/src/utils.jl#L72-L82" target="_blank" rel="noreferrer">source</a></p>`,5))])])}const ke=n(d,[["render",oe]]);export{he as __pageData,ke as default};
