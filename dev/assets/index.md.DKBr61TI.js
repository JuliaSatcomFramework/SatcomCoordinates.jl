import{_ as n,c as l,j as i,a as t,G as a,ai as o,B as r,o as d}from"./chunks/framework.hSlKf8er.js";const F=JSON.parse('{"title":"SatcomCoordinates.jl","description":"","frontmatter":{},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),p={name:"index.md"},c={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""};function v(C,e,E,_,A,S){const s=r("Badge");return d(),l("div",null,[e[30]||(e[30]=i("h1",{id:"satcomcoordinates-jl",tabindex:"-1"},[t("SatcomCoordinates.jl "),i("a",{class:"header-anchor",href:"#satcomcoordinates-jl","aria-label":'Permalink to "SatcomCoordinates.jl"'},"​")],-1)),e[31]||(e[31]=i("p",null,[t("Documentation for "),i("code",null,"SatcomCoordinates.jl"),t(".")],-1)),i("details",c,[i("summary",null,[e[0]||(e[0]=i("a",{id:"SatcomCoordinates.AbstractSatcomCoordinate",href:"#SatcomCoordinates.AbstractSatcomCoordinate"},[i("span",{class:"jlbinding"},"SatcomCoordinates.AbstractSatcomCoordinate")],-1)),e[1]||(e[1]=t()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[2]||(e[2]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>General abstract type identifying a <em>coordinate</em> with <code>N</code> dimensions and an underlying number type <code>T</code>. The number type <code>T</code> is not necessarily the type of the fields in the type instance, but the underlying real type of the fields (this is used for Unitful quantities, such that <code>numbertype(::Quantity{T}) where T = T</code>).</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The term <em>coordinate</em> is used here in a loose sense, identifying both position in space as well as pointing directions</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/abstract_types.jl#L1-L8" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",h,[i("summary",null,[e[3]||(e[3]=i("a",{id:"SatcomCoordinates.AngularPointing",href:"#SatcomCoordinates.AngularPointing"},[i("span",{class:"jlbinding"},"SatcomCoordinates.AngularPointing")],-1)),e[4]||(e[4]=t()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[5]||(e[5]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AngularPointing{T}</span></span></code></pre></div><p>Abstract type representing a pointing direction identified by two angles in degrees, represented with fields of types <code>Deg{T}</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/abstract_types.jl#L23-L28" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",g,[i("summary",null,[e[6]||(e[6]=i("a",{id:"SatcomCoordinates.AzOverEl",href:"#SatcomCoordinates.AzOverEl"},[i("span",{class:"jlbinding"},"SatcomCoordinates.AzOverEl")],-1)),e[7]||(e[7]=t()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[8]||(e[8]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AzOverEl{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Azimuth over Elevation&quot; coordinates, which specify the elevation and azimuth angles that needs to be fed to an azimuth-over-elevation positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>Az</code> and <code>El</code> angles is:</p><ul><li><p><code>u = sin(Az)</code></p></li><li><p><code>v = cos(Az) * sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The equations above are used to represent the &quot;Azimuth over Elevation&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with a possible flip in the az/u sign) are used to describe an &quot;Elevation over Azimuth&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The fields of <code>AzOverEl</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/pointing/types.jl#L106-L127" target="_blank" rel="noreferrer">source</a></p>',12))]),i("details",u,[i("summary",null,[e[9]||(e[9]=i("a",{id:"SatcomCoordinates.CartesianPosition",href:"#SatcomCoordinates.CartesianPosition"},[i("span",{class:"jlbinding"},"SatcomCoordinates.CartesianPosition")],-1)),e[10]||(e[10]=t()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[11]||(e[11]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CartesianPosition{T, N} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>Abstract type representing a coordinate in <code>N</code> dimensions which is backed by fields all of type <code>T</code>. Concrete subtypes of this are subtypes of <code>FieldVector</code></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/abstract_types.jl#L11-L17" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",k,[i("summary",null,[e[12]||(e[12]=i("a",{id:"SatcomCoordinates.ElOverAz",href:"#SatcomCoordinates.ElOverAz"},[i("span",{class:"jlbinding"},"SatcomCoordinates.ElOverAz")],-1)),e[13]||(e[13]=t()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[14]||(e[14]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ElOverAz{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Elevation over Azimuth&quot; coordinates, which specify the azimuth and elevation angles that needs to be fed to an elevation-over-azimuth positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>El</code> and <code>Az</code> angles is:</p><ul><li><p><code>u = -sin(Az) * cos(El)</code></p></li><li><p><code>v = sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The equations above are used to represent the &quot;Elevation over Azimuth&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with sometimes an additional flip in the az/u sign) are used to describe an &quot;Azimuth over Elevation&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The fields of <code>ElOverAz</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/pointing/types.jl#L136-L159" target="_blank" rel="noreferrer">source</a></p>',13))]),i("details",m,[i("summary",null,[e[15]||(e[15]=i("a",{id:"SatcomCoordinates.PointingVersor",href:"#SatcomCoordinates.PointingVersor"},[i("span",{class:"jlbinding"},"SatcomCoordinates.PointingVersor")],-1)),e[16]||(e[16]=t()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[17]||(e[17]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PointingVersor{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T, 3}</span></span></code></pre></div><p>A unit vector (versor) representing a pointing direction in 3D space. Its components are the <code>x</code>, <code>y</code>, and <code>z</code> components of the unit vector and can also be seen as the <code>u</code>, <code>v</code>, and <code>w</code> direction cosines of the direction identified by the <code>PointingVersor</code> instance.</p><p><strong>Fields</strong></p><ul><li><p><code>x::T</code>: The component along the X axis of the corresponding reference frame. Can also be accessed with the <code>u</code> property name.</p></li><li><p><code>y::T</code>: The component along the Y axis of the corresponding reference frame. Can also be accessed with the <code>v</code> property name.</p></li><li><p><code>z::T</code>: The component along the Z axis of the corresponding reference frame. Can also be accessed with the <code>w</code> property name.</p></li></ul><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.ElOverAz"><code>ElOverAz</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/pointing/types.jl#L1-L15" target="_blank" rel="noreferrer">source</a></p>',6))]),i("details",b,[i("summary",null,[e[18]||(e[18]=i("a",{id:"SatcomCoordinates.ThetaPhi",href:"#SatcomCoordinates.ThetaPhi"},[i("span",{class:"jlbinding"},"SatcomCoordinates.ThetaPhi")],-1)),e[19]||(e[19]=t()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[20]||(e[20]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThetaPhi{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>An object specifying a pointing direction in ThetaPhi coordinates, defined as the θ and φ in the (ISO/Physics definition) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a></p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>θ</code> and <code>φ</code> angles is:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li><li><p><code>w = cos(θ)</code></p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>θ::Deg{T}</code>: The so-called <code>polar angle</code>, representing the angle between the <code>Z</code> axis and the <code>XY</code> plane of the reference frame. It is always normalized to fall within the [-90°, 90°] range.</p></li><li><p><code>φ::Deg{T}</code>: The so-called <code>azimuth angle</code>, representing the angle between the <code>y</code> and <code>x</code> component of the pointing direction. It is always normalized to fall within the [-180°, 180°] range.</p></li></ul><p>While the field name use the greek letters, the specific fields of an arbitrary <code>ThetaPhi</code> object <code>tp</code> can be accessed with alternative symbols:</p><ul><li><p><code>tp.θ</code>, <code>tp.theta</code> and <code>tp.t</code> can be used to access the <code>θ</code> field</p></li><li><p><code>tp.φ</code>, <code>tp.ϕ</code>, <code>tp.phi</code> and <code>tp.p</code> can be used to access the <code>φ</code> field</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(θ,φ)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>θ</code>, <code>φ</code> and instantiate the object. MarkdownAST.LineBreak()</p><p><strong>Provided inputs are intepreted as degrees if not provided using angular quantities from Unitful.</strong> If either of the inputs is <code>NaN</code>, the returned <code>ThetaPhi</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(tp)</span></span></code></pre></div><p>The <code>ThetaPhi</code> struct can be created using any 2-element Tuple or Vector/StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/pointing/types.jl#L64-L98" target="_blank" rel="noreferrer">source</a></p>',16))]),i("details",y,[i("summary",null,[e[21]||(e[21]=i("a",{id:"SatcomCoordinates.UV",href:"#SatcomCoordinates.UV"},[i("span",{class:"jlbinding"},"SatcomCoordinates.UV")],-1)),e[22]||(e[22]=t()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[23]||(e[23]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UV{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T, 2}</span></span></code></pre></div><p>Specify a pointing direction in UV coordinates, which are equivalent to the direction cosines with respect to the <code>X</code> and <code>Y</code> axis of the reference frame. They can also be related to the spherical coordinates (ISO/Physics) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a> by the following equations:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>UV coordinates can only be used to represent pointing direction in the half-hemisphere containing the cartesian +Z axis.</p></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The inputs values must also satisfy <code>u^2 + v^2 &lt;= 1 + SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE[]</code> or an error will be thrown. The <code>SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE</code> is a <code>Ref{Float64}</code> which defaults to 1e-5 (In case <code>u^2 + v^2 &gt; 1</code> the inputs are normalized to ensure <code>u^2 + v^2 = 1</code>).</p></div><p><strong>Fields</strong></p><ul><li><p><code>u::T</code></p></li><li><p><code>v::T</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(u,v)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>u</code>, <code>v</code> and instantiate the object assuming that <code>u^2 + v^2 &lt;= 1</code> (condition for valid UV pointing), throwing an error otherwise. MarkdownAST.LineBreak()</p><p>If either of the inputs is <code>NaN</code>, the returned <code>UV</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(uv)</span></span></code></pre></div><p>The <code>UV{T}</code> can be created using any 2-element Tuple or StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/pointing/types.jl#L25-L56" target="_blank" rel="noreferrer">source</a></p>',15))]),i("details",T,[i("summary",null,[e[24]||(e[24]=i("a",{id:"SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T<:Union{AzOverEl, ElOverAz, ThetaPhi}",href:"#SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T<:Union{AzOverEl, ElOverAz, ThetaPhi}"},[i("span",{class:"jlbinding"},"SatcomCoordinates.wrap_spherical_angles")],-1)),e[25]||(e[25]=t()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[26]||(e[26]=o(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><p>!!!</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/utils.jl#L37-L46" target="_blank" rel="noreferrer">source</a></p>`,5))]),i("details",f,[i("summary",null,[e[27]||(e[27]=i("a",{id:"SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{<:Union{AzOverEl, ElOverAz}}}} where T<:(Unitful.Quantity{<:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})",href:"#SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{<:Union{AzOverEl, ElOverAz}}}} where T<:(Unitful.Quantity{<:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})"},[i("span",{class:"jlbinding"},"SatcomCoordinates.wrap_spherical_angles_normalized")],-1)),e[28]||(e[28]=t()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[29]||(e[29]=o(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>This function already assumes that the provided input angles are already normalized such that both are in the [-180°, 180°] range. If you want to normalize the inputs automatically use the <code>wrap_first_angle</code> function.</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/c7f6528eeae9eae28bd03f69e2abb69cb28677c5/src/utils.jl#L12-L22" target="_blank" rel="noreferrer">source</a></p>`,5))])])}const w=n(p,[["render",v]]);export{F as __pageData,w as default};
