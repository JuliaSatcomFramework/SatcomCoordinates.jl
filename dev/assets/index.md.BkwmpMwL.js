import{_ as o,c as l,j as i,a as s,G as a,ai as n,B as p,o as r}from"./chunks/framework.hSlKf8er.js";const L=JSON.parse('{"title":"SatcomCoordinates.jl","description":"","frontmatter":{},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),d={name:"index.md"},h={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""};function V(U,e,N,x,B,z){const t=p("Badge");return r(),l("div",null,[e[63]||(e[63]=i("h1",{id:"satcomcoordinates-jl",tabindex:"-1"},[s("SatcomCoordinates.jl "),i("a",{class:"header-anchor",href:"#satcomcoordinates-jl","aria-label":'Permalink to "SatcomCoordinates.jl"'},"​")],-1)),e[64]||(e[64]=i("p",null,[s("Documentation for "),i("code",null,"SatcomCoordinates.jl"),s(".")],-1)),i("details",h,[i("summary",null,[e[0]||(e[0]=i("a",{id:"SatcomCoordinates.AbstractSatcomCoordinate",href:"#SatcomCoordinates.AbstractSatcomCoordinate"},[i("span",{class:"jlbinding"},"SatcomCoordinates.AbstractSatcomCoordinate")],-1)),e[1]||(e[1]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[2]||(e[2]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>General abstract type identifying a <em>coordinate</em> with <code>N</code> dimensions and an underlying number type <code>T</code>. The number type <code>T</code> is not necessarily the type of the fields in the type instance, but the underlying real type of the fields (this is used for Unitful quantities, such that <code>numbertype(::Quantity{T}) where T = T</code>).</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The term <em>coordinate</em> is used here in a loose sense, identifying both position in space as well as pointing directions</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/abstract_types.jl#L1-L8" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",c,[i("summary",null,[e[3]||(e[3]=i("a",{id:"SatcomCoordinates.AngularPointing",href:"#SatcomCoordinates.AngularPointing"},[i("span",{class:"jlbinding"},"SatcomCoordinates.AngularPointing")],-1)),e[4]||(e[4]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[5]||(e[5]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AngularPointing{T}</span></span></code></pre></div><p>Abstract type representing a pointing direction identified by two angles in degrees, represented with fields of types <code>Deg{T}</code>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/abstract_types.jl#L25-L30" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",k,[i("summary",null,[e[6]||(e[6]=i("a",{id:"SatcomCoordinates.AzOverEl",href:"#SatcomCoordinates.AzOverEl"},[i("span",{class:"jlbinding"},"SatcomCoordinates.AzOverEl")],-1)),e[7]||(e[7]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[8]||(e[8]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AzOverEl{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Azimuth over Elevation&quot; coordinates, which specify the elevation and azimuth angles that needs to be fed to an azimuth-over-elevation positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>Az</code> and <code>El</code> angles is:</p><ul><li><p><code>u = -sin(Az)</code></p></li><li><p><code>v = cos(Az) * sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The equations above are used to represent the &quot;Azimuth over Elevation&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with a possible flip in the az/u sign) are used to describe an &quot;Elevation over Azimuth&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The fields of <code>AzOverEl</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/pointing.jl#L106-L127" target="_blank" rel="noreferrer">source</a></p>',12))]),i("details",g,[i("summary",null,[e[9]||(e[9]=i("a",{id:"SatcomCoordinates.CartesianPosition",href:"#SatcomCoordinates.CartesianPosition"},[i("span",{class:"jlbinding"},"SatcomCoordinates.CartesianPosition")],-1)),e[10]||(e[10]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[11]||(e[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CartesianPosition{T, N} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractSatcomCoordinate{T, N}</span></span></code></pre></div><p>Abstract type representing a coordinate in <code>N</code> dimensions which is backed by fields all of type <code>T</code>. Concrete subtypes of this are subtypes of <code>FieldVector</code></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/abstract_types.jl#L13-L19" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",u,[i("summary",null,[e[12]||(e[12]=i("a",{id:"SatcomCoordinates.ECEF",href:"#SatcomCoordinates.ECEF"},[i("span",{class:"jlbinding"},"SatcomCoordinates.ECEF")],-1)),e[13]||(e[13]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[14]||(e[14]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ECEF{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the Earth-Centered, Earth-Fixed (ECEF) coordinate system (or generically for other planets, Ellipsoid-Centered, Ellipsoid-Fixed).</p><p><strong>Fields</strong></p><p>x::Met{T}: X-coordinate in meters y::Met{T}: Y-coordinate in meters z::Met{T}: Z-coordinate in meters</p><p><strong>Basic Constructors</strong></p><p>ECEF(x::ValidDistance, y::ValidDistance, z::ValidDistance)</p><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>ECEF</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECI"><code>ECI</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#LLA"><code>LLA</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/geocentered.jl#L1-L22" target="_blank" rel="noreferrer">source</a></p>',12))]),i("details",m,[i("summary",null,[e[15]||(e[15]=i("a",{id:"SatcomCoordinates.ECI",href:"#SatcomCoordinates.ECI"},[i("span",{class:"jlbinding"},"SatcomCoordinates.ECI")],-1)),e[16]||(e[16]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[17]||(e[17]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ECI{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LengthCartesian{T, 3}</span></span></code></pre></div><p>Represents a position in the Earth-Centered, Inertial (ECI) coordinate system (or generically for other planets, Ellipsoid-Centered, Inertial).</p><p><strong>Fields</strong></p><p>x::Met{T}: X-coordinate in meters y::Met{T}: Y-coordinate in meters z::Met{T}: Z-coordinate in meters</p><p><strong>Basic Constructors</strong></p><p>ECI(x::ValidDistance, y::ValidDistance, z::ValidDistance)</p><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>ECI</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECEF"><code>ECEF</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#LLA"><code>LLA</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/geocentered.jl#L31-L52" target="_blank" rel="noreferrer">source</a></p>',12))]),i("details",y,[i("summary",null,[e[18]||(e[18]=i("a",{id:"SatcomCoordinates.ElOverAz",href:"#SatcomCoordinates.ElOverAz"},[i("span",{class:"jlbinding"},"SatcomCoordinates.ElOverAz")],-1)),e[19]||(e[19]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[20]||(e[20]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ElOverAz{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>Object specifying a pointing direction in &quot;Elevation over Azimuth&quot; coordinates, which specify the azimuth and elevation angles that needs to be fed to an elevation-over-azimuth positioner for pointing to a target towards the pointing direction ̂p.</p><p>Following the convention used in most Antenna-related literature, the elevation and azimuth are 0° in the direction of the +Z axis of the reference frame.</p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>El</code> and <code>Az</code> angles is:</p><ul><li><p><code>u = -sin(Az) * cos(El)</code></p></li><li><p><code>v = sin(El)</code></p></li><li><p><code>w = cos(Az) * cos(El)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The equations above are used to represent the &quot;Elevation over Azimuth&quot; coordinates in GRASP. Some textbooks, however, use the opposite convention, meaning that the same equations (with sometimes an additional flip in the az/u sign) are used to describe an &quot;Azimuth over Elevation&quot; coordinate system. This is for example the case in the book <em>&quot;Theory and Practice of Modern Antenna Range Measurements&quot;</em> by Clive Parini et al.</p><p><strong>Fields</strong></p><ul><li><p><code>az::Deg{T}: The azimuth angle in degrees, constrained to be in the [-180°, 180°] range.</code></p></li><li><p><code>el::Deg{T}: The elevation angle in degrees, constrained to be in the [-90°, 90°] range.</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p></div><p>The fields of <code>ElOverAz</code> objects can also be accessed via <code>getproperty</code> using the <code>azimuth</code> and <code>elevation</code> aliases.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/pointing.jl#L136-L159" target="_blank" rel="noreferrer">source</a></p>',13))]),i("details",E,[i("summary",null,[e[21]||(e[21]=i("a",{id:"SatcomCoordinates.LLA",href:"#SatcomCoordinates.LLA"},[i("span",{class:"jlbinding"},"SatcomCoordinates.LLA")],-1)),e[22]||(e[22]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[23]||(e[23]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LLA{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngleAngleDistance{T}</span></span></code></pre></div><p>Identify a point on or above earth using geodetic coordinates</p><p><strong>Fields</strong></p><p>lat::Deg{T}: Latitude of the point in degrees [-90°, 90°] lon::Deg{T}: Longitude of the point in degrees [-180°, 180°] alt::Met{T}: Altitude of the point above the reference ellipsoid</p><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LLA(lat::ValidAngle,lon::ValidAngle,alt::ValidDistance)</span></span>
<span class="line"><span>LLA(lat::ValidAngle,lon::ValidAngle) # Defaults to 0m altitude</span></span></code></pre></div><p><code>ValidAngle</code> is a either a Real number or a <code>Unitful.Quantity</code> of unit either <code>u&quot;rad&quot;</code> or <code>u&quot;°&quot;</code>.</p><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p><p>If of the provided argument is <code>NaN</code>, the returned <code>LLA</code> object will contain <code>NaN</code> for all fields.</p><p><strong>Fallback constructors</strong></p><p>All subtypes of <code>P &lt;: AbstractSatcomCoordinate</code> can also be constructed using a Tuple or SVector as input, which will be <code>splatted</code> into the standard constructor for <code>P</code></p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#ECEF"><code>ECEF</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ECI"><code>ECI</code></a>.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/geocentered.jl#L61-L86" target="_blank" rel="noreferrer">source</a></p>`,13))]),i("details",b,[i("summary",null,[e[24]||(e[24]=i("a",{id:"SatcomCoordinates.PointingVersor",href:"#SatcomCoordinates.PointingVersor"},[i("span",{class:"jlbinding"},"SatcomCoordinates.PointingVersor")],-1)),e[25]||(e[25]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[26]||(e[26]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PointingVersor{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T, 3}</span></span></code></pre></div><p>A unit vector (versor) representing a pointing direction in 3D space. Its components are the <code>x</code>, <code>y</code>, and <code>z</code> components of the unit vector and can also be seen as the <code>u</code>, <code>v</code>, and <code>w</code> direction cosines of the direction identified by the <code>PointingVersor</code> instance.</p><p><strong>Fields</strong></p><ul><li><p><code>x::T</code>: The component along the X axis of the corresponding reference frame. Can also be accessed with the <code>u</code> property name.</p></li><li><p><code>y::T</code>: The component along the Y axis of the corresponding reference frame. Can also be accessed with the <code>v</code> property name.</p></li><li><p><code>z::T</code>: The component along the Z axis of the corresponding reference frame. Can also be accessed with the <code>w</code> property name.</p></li></ul><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#AzOverEl"><code>AzOverEl</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ElOverAz"><code>ElOverAz</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/pointing.jl#L1-L15" target="_blank" rel="noreferrer">source</a></p>',6))]),i("details",f,[i("summary",null,[e[27]||(e[27]=i("a",{id:"SatcomCoordinates.ThetaPhi",href:"#SatcomCoordinates.ThetaPhi"},[i("span",{class:"jlbinding"},"SatcomCoordinates.ThetaPhi")],-1)),e[28]||(e[28]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[29]||(e[29]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThetaPhi{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AngularPointing{T}</span></span></code></pre></div><p>An object specifying a pointing direction in ThetaPhi coordinates, defined as the θ and φ in the (ISO/Physics definition) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a></p><p>Assuming <code>u</code>, <code>v</code>, and <code>w</code> to be direction cosines of the pointing versor <code>̂p</code>, their relation with the <code>θ</code> and <code>φ</code> angles is:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li><li><p><code>w = cos(θ)</code></p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>θ::Deg{T}</code>: The so-called <code>polar angle</code>, representing the angle between the <code>Z</code> axis and the <code>XY</code> plane of the reference frame. It is always normalized to fall within the [-90°, 90°] range.</p></li><li><p><code>φ::Deg{T}</code>: The so-called <code>azimuth angle</code>, representing the angle between the <code>y</code> and <code>x</code> component of the pointing direction. It is always normalized to fall within the [-180°, 180°] range.</p></li></ul><p>While the field name use the greek letters, the specific fields of an arbitrary <code>ThetaPhi</code> object <code>tp</code> can be accessed with alternative symbols:</p><ul><li><p><code>tp.θ</code>, <code>tp.theta</code> and <code>tp.t</code> can be used to access the <code>θ</code> field</p></li><li><p><code>tp.φ</code>, <code>tp.ϕ</code>, <code>tp.phi</code> and <code>tp.p</code> can be used to access the <code>φ</code> field</p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(θ,φ)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>θ</code>, <code>φ</code> and instantiate the object. MarkdownAST.LineBreak()</p><p><strong>Provided inputs are intepreted as degrees if not provided using angular quantities from Unitful.</strong> If either of the inputs is <code>NaN</code>, the returned <code>ThetaPhi</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ThetaPhi(tp)</span></span></code></pre></div><p>The <code>ThetaPhi</code> struct can be created using any 2-element Tuple or Vector/StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/pointing.jl#L64-L98" target="_blank" rel="noreferrer">source</a></p>',16))]),i("details",C,[i("summary",null,[e[30]||(e[30]=i("a",{id:"SatcomCoordinates.UV",href:"#SatcomCoordinates.UV"},[i("span",{class:"jlbinding"},"SatcomCoordinates.UV")],-1)),e[31]||(e[31]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[32]||(e[32]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UV{T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPointing{T, 2}</span></span></code></pre></div><p>Specify a pointing direction in UV coordinates, which are equivalent to the direction cosines with respect to the <code>X</code> and <code>Y</code> axis of the reference frame. They can also be related to the spherical coordinates (ISO/Physics) <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system" target="_blank" rel="noreferrer">spherical coordinates representation</a> by the following equations:</p><ul><li><p><code>u = sin(θ) * cos(φ)</code></p></li><li><p><code>v = sin(θ) * sin(φ)</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>UV coordinates can only be used to represent pointing direction in the half-hemisphere containing the cartesian +Z axis.</p></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>The inputs values must also satisfy <code>u^2 + v^2 &lt;= 1 + SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE[]</code> or an error will be thrown. The <code>SatcomCoordinates.UV_CONSTRUCTOR_TOLERANCE</code> is a <code>Ref{Float64}</code> which defaults to 1e-5 (In case <code>u^2 + v^2 &gt; 1</code> the inputs are normalized to ensure <code>u^2 + v^2 = 1</code>).</p></div><p><strong>Fields</strong></p><ul><li><p><code>u::T</code></p></li><li><p><code>v::T</code></p></li></ul><p><strong>Basic Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(u,v)</span></span></code></pre></div><p>The basic constructor takes 2 separate numbers <code>u</code>, <code>v</code> and instantiate the object assuming that <code>u^2 + v^2 &lt;= 1</code> (condition for valid UV pointing), throwing an error otherwise. MarkdownAST.LineBreak()</p><p>If either of the inputs is <code>NaN</code>, the returned <code>UV</code> object will contain <code>NaN</code> for both fields.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UV{T}(uv)</span></span></code></pre></div><p>The <code>UV{T}</code> can be created using any 2-element Tuple or StaticVector as input, which will internally call the 2-arguments constructor.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/performance#PointingVersor"><code>PointingVersor</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/types/pointing.jl#L25-L56" target="_blank" rel="noreferrer">source</a></p>',15))]),i("details",T,[i("summary",null,[e[33]||(e[33]=i("a",{id:"SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O<:AbstractPointing, P<:AbstractPointing}",href:"#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O<:AbstractPointing, P<:AbstractPointing}"},[i("span",{class:"jlbinding"},"SatcomCoordinates.add_angular_offset")],-1)),e[34]||(e[34]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₀</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, offset_angles</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThetaPhi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₀</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointingType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output_type, p₀, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the resulting pointing direction <code>p</code> obtained by adding an angular offset expressed as θ and φ angles (following the ISO/Physics convention for spherical coordinates) [deg] to the starting position identified by <code>p₀</code>.</p><p>The input starting position <code>p₀</code> must be any subtype of <code>AbstractPointing</code> The input <code>offset_angles</code> can be provided as an instance of one of the following types:</p><ul><li><p><code>ThetaPhi</code></p></li><li><p><code>ThetaPhiOffset</code></p></li><li><p><code>Point2D</code></p></li></ul><p>and is converted to <code>ThetaPhiOffset</code> internally, with non-unitful values being interpreted as angles in degrees.</p><p>The output is of type <code>output_type</code> if provided or of the same type as <code>p₀</code> otherwise.</p><p><strong>Note</strong></p><p>If <code>output_type</code> is <code>UV</code>, the function will throw an error if the final pointing direction is located behind the viewer as the output in UV would be ambiguous. This is not the case for other subtypes of <code>AbstractPointing</code> so an explicit output type (different from <code>UV</code>) should be provided if the target is expected to be behind the viewer.</p><p>The offset angles can also be provided separately as 2nd and 3rd argument (optional, defaults to 0.0) to the function using the second method signature. In this case, the inputs are treated as angles in degrees unless explicitly provided using quantitites with <code>°</code> unit from the Unitful package.</p><p>This function performs the inverse operation of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a> so the following code should return true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SatcomCoordinates</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, offset)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv2</span></span></code></pre></div><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_distance</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#ThetaPhi"><code>ThetaPhi</code></a>, <a href="/SatcomCoordinates.jl/dev/performance#UV"><code>UV</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/functions/pointing.jl#L312-L351" target="_blank" rel="noreferrer">source</a></p>`,13))]),i("details",v,[i("summary",null,[e[36]||(e[36]=i("a",{id:"SatcomCoordinates.angle_offset_rotation-Tuple{Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T}",href:"#SatcomCoordinates.angle_offset_rotation-Tuple{Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T}"},[i("span",{class:"jlbinding"},"SatcomCoordinates.angle_offset_rotation")],-1)),e[37]||(e[37]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[38]||(e[38]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">angle_offset_rotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ, φ)</span></span></code></pre></div><p>Compute the rotation matrix to find offset points following the procedure in this stackexchnge answer: <a href="https://math.stackexchange.com/questions/4343044/rotate-vector-by-a-random-little-amount" target="_blank" rel="noreferrer">https://math.stackexchange.com/questions/4343044/rotate-vector-by-a-random-little-amount</a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/functions/pointing.jl#L225-L231" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",_,[i("summary",null,[e[39]||(e[39]=i("a",{id:"SatcomCoordinates.asdeg-Tuple{Real}",href:"#SatcomCoordinates.asdeg-Tuple{Real}"},[i("span",{class:"jlbinding"},"SatcomCoordinates.asdeg")],-1)),e[40]||(e[40]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[41]||(e[41]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">asdeg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert the provided value assumed to be in radians to Unitful degrees.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/utils.jl#L105-L109" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",F,[i("summary",null,[e[42]||(e[42]=i("a",{id:"SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}",href:"#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"},[i("span",{class:"jlbinding"},"SatcomCoordinates.get_angular_distance")],-1)),e[43]||(e[43]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[44]||(e[44]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_angular_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₁</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p₂</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the angular distance [°] between the target pointing direction <code>p₂</code> and the starting pointing direction <code>p₁</code>.</p><p><strong>Note</strong></p><p>This function&#39;s output should be approximately equivalent to the θ (theta) component of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a> but has a faster implementation. Use this in case the φ (phi) component is not required and speed is important. The following code should evaluate to true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SatcomCoordinates</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Δθ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">theta </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Δθ</span></span></code></pre></div><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a>, <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_offset</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/functions/pointing.jl#L197-L218" target="_blank" rel="noreferrer">source</a></p>`,7))]),i("details",A,[i("summary",null,[e[45]||(e[45]=i("a",{id:"SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}",href:"#SatcomCoordinates.get_angular_offset-Tuple{AbstractPointing, AbstractPointing}"},[i("span",{class:"jlbinding"},"SatcomCoordinates.get_angular_offset")],-1)),e[46]||(e[46]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[47]||(e[47]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p₁</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p₂</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractPointing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThetaPhiOffset</span></span></code></pre></div><p>Compute the angular offset required to reach the target pointing direction <code>p₂</code> from starting pointing direction <code>p₁</code>. The two input pointings can be of any valid <code>AbstractPointing</code> type.</p><p>The output is of type <code>ThetaPhiOffset</code></p><p><strong>Note</strong></p><p>This function performs the inverse operation of <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a> so the following code should return true</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReferenceViews</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, uv2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> add_angular_offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv1, offset)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">≈</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv2</span></span></code></pre></div><p>Check out <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.get_angular_distance-Tuple{AbstractPointing, AbstractPointing}"><code>get_angular_distance</code></a> for a slightly faster implementation in case you only require the angular distance rather than the 2D offset.</p><p>See also: <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.add_angular_offset-Union{Tuple{P}, Tuple{O}, Tuple{Type{O}, P, ThetaPhi}} where {O&lt;:AbstractPointing, P&lt;:AbstractPointing}"><code>add_angular_offset</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/functions/pointing.jl#L274-L299" target="_blank" rel="noreferrer">source</a></p>`,9))]),i("details",S,[i("summary",null,[e[48]||(e[48]=i("a",{id:"SatcomCoordinates.raw_nt-Tuple{C} where C<:AbstractSatcomCoordinate",href:"#SatcomCoordinates.raw_nt-Tuple{C} where C<:AbstractSatcomCoordinate"},[i("span",{class:"jlbinding"},"SatcomCoordinates.raw_nt")],-1)),e[49]||(e[49]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[50]||(e[50]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">raw_nt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSatcomCoordinate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generated a NamedTuple from the provided Object which has the same names as the object fields but contains <em>normalized</em> values of its fields</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>By <em>normalized</em> we mean that fields containing Uniftul quantities are stripped of their units and in the case of <code>Deg</code> fields, they are converted to radians as trig functions are faster for radians inputs.</p></div><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.to_svector-Tuple{C} where C&lt;:AbstractSatcomCoordinate"><code>to_svector</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/utils.jl#L79-L87" target="_blank" rel="noreferrer">source</a></p>',5))]),i("details",j,[i("summary",null,[e[51]||(e[51]=i("a",{id:"SatcomCoordinates.stripdeg-Tuple{Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T}",href:"#SatcomCoordinates.stripdeg-Tuple{Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T}"},[i("span",{class:"jlbinding"},"SatcomCoordinates.stripdeg")],-1)),e[52]||(e[52]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[53]||(e[53]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stripdeg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Deg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Strip the units from the provided <code>Deg</code> field and convert it to radians.</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/utils.jl#L112-L116" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",P,[i("summary",null,[e[54]||(e[54]=i("a",{id:"SatcomCoordinates.to_svector-Tuple{C} where C<:AbstractSatcomCoordinate",href:"#SatcomCoordinates.to_svector-Tuple{C} where C<:AbstractSatcomCoordinate"},[i("span",{class:"jlbinding"},"SatcomCoordinates.to_svector")],-1)),e[55]||(e[55]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[56]||(e[56]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">to_svector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coord</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSatcomCoordinate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate the unitless SVector containing the <em>normalized</em> fields of the provided coordinate.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>By <em>normalized</em> we mean that fields containing Uniftul quantities are stripped of their units and in the case of <code>Deg</code> fields, they are converted to radians as trig functions are faster for radians inputs.</p></div><p>See also <a href="/SatcomCoordinates.jl/dev/index#SatcomCoordinates.raw_nt-Tuple{C} where C&lt;:AbstractSatcomCoordinate"><code>raw_nt</code></a></p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/utils.jl#L65-L74" target="_blank" rel="noreferrer">source</a></p>',5))]),i("details",w,[i("summary",null,[e[57]||(e[57]=i("a",{id:"SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T<:Union{AzOverEl, ElOverAz, ThetaPhi}",href:"#SatcomCoordinates.wrap_spherical_angles-Union{Tuple{T}, Tuple{Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Union{Real, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}} where T, Unitful.Quantity{T, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}} where T}, Type{T}}} where T<:Union{AzOverEl, ElOverAz, ThetaPhi}"},[i("span",{class:"jlbinding"},"SatcomCoordinates.wrap_spherical_angles")],-1)),e[58]||(e[58]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[59]||(e[59]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ValidAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><p>!!!</p><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/utils.jl#L37-L46" target="_blank" rel="noreferrer">source</a></p>`,5))]),i("details",D,[i("summary",null,[e[60]||(e[60]=i("a",{id:"SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{<:Union{AzOverEl, ElOverAz}}}} where T<:(Unitful.Quantity{<:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})",href:"#SatcomCoordinates.wrap_spherical_angles_normalized-Union{Tuple{T}, Tuple{T, T, Type{<:Union{AzOverEl, ElOverAz}}}} where T<:(Unitful.Quantity{<:Real, NoDims, Unitful.FreeUnits{(°,), NoDims, nothing}})"},[i("span",{class:"jlbinding"},"SatcomCoordinates.wrap_spherical_angles_normalized")],-1)),e[61]||(e[61]=s()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[62]||(e[62]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">az, el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(az</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:ThetaPhi}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ, φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrap_spherical_angles_normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, φ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:Union{AzOverEl, ElOverAz}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Deg{&lt;:Real}</span></span></code></pre></div><p>Function that takes as input two angles representing two orthogonal angular components of spherical coordinates (e.g. θ/φ, el/az, etc.) and returns two angles normalized to a consistent wrapping identifying the full sphere:</p><ul><li><p><code>θ/φ</code> angles are wrapped such that <code>θ ∈ [0°, 180°]</code> and <code>φ ∈ [-180°, 180°]</code></p></li><li><p><code>el/az</code> angles are wrapped such that <code>el ∈ [-90°, 90°]</code> and <code>az ∈ [-180°, 180°]</code></p></li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><p>This function already assumes that the provided input angles are already normalized such that both are in the [-180°, 180°] range. If you want to normalize the inputs automatically use the <code>wrap_first_angle</code> function.</p></div><p><a href="https://github.com/JuliaSatcomFramework/SatcomCoordinates.jl/blob/af726e403e0b66c17ed56dca09ec58e7da3e6738/src/utils.jl#L12-L22" target="_blank" rel="noreferrer">source</a></p>`,5))])])}const I=o(d,[["render",V]]);export{L as __pageData,I as default};
